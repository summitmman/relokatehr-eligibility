<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <style>
        #page.container {
            max-width: 100%;
            padding: 0px;
        }
        .lds-ellipsis {
            /* display: inline-block; */
            margin: 80px auto;
            position: relative;
            width: 80px;
            height: 80px;
        }
        .lds-ellipsis div {
            position: absolute;
            top: 33px;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: #444;
            animation-timing-function: cubic-bezier(0, 1, 1, 0);
        }
        .lds-ellipsis div:nth-child(1) {
            left: 8px;
            animation: lds-ellipsis1 0.6s infinite;
        }
        .lds-ellipsis div:nth-child(2) {
            left: 8px;
            animation: lds-ellipsis2 0.6s infinite;
        }
        .lds-ellipsis div:nth-child(3) {
            left: 32px;
            animation: lds-ellipsis2 0.6s infinite;
        }
        .lds-ellipsis div:nth-child(4) {
            left: 56px;
            animation: lds-ellipsis3 0.6s infinite;
        }
        @keyframes lds-ellipsis1 {
            0% {
                transform: scale(0);
            }
            100% {
                transform: scale(1);
            }
        }
        @keyframes lds-ellipsis3 {
            0% {
                transform: scale(1);
            }
            100% {
                transform: scale(0);
            }
        }
        @keyframes lds-ellipsis2 {
            0% {
                transform: translate(0, 0);
            }
            100% {
                transform: translate(24px, 0);
            }
        }
    </style>
    <style>
        .myfade {
            opacity: 0;
            transition: all 0.3s ease;
        }
        .myfade-in {
            opacity: 1;
        }
        .cursor-pointer {
            cursor: pointer;
        }
        .back-section {
            height: 16px;
            margin-top: 10px;
        }
        .progress {
            display: inline-block;
            position: absolute;
            height: 6px;
            border-radius: 10px;
        }
        .height-6 {
            height: 6px;
        }
        .progress-back {
            background-color: #AAA;
        }
        .progress-bar {
            background-color: #444;
        }
        .position-relative {
            position: relative;
        }
        .step-section {
            height: 42px;
            margin-top: 20px;
        }
        .step-no {
            font-size: small;
        }
        .margin-top-20 {
            margin-top: 20px;
        }
        .margin-top-50 {
            margin-top: 50px;
        }
        .text-align-center {
            text-align: center;
        }
        .form-prompt {
            margin-top: 15px;
        }
        .form-label {
            font-weight: bold;
        }
        .display-none {
            display: none;
        }
        .display-block {
            display: block;
        }
        .helperText {
            font-size: 14px;
            border: none;
            background-color: transparent;
        }
    </style>
</head>
<body>
    <div id="quizApp" class="container">
        <div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
    </div>

    <script src="https://kit.fontawesome.com/6f2a26d215.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <script>
        // @ts-check

        // Global store
        const store = {
            countries: null,
            visibleOnMap: {}
        };
        const idAppends = {
            Option: "Option",
            QuestionDiv: "QuestionDiv"
        };

        const useServices = () => {
            // const domain = "http://localhost:3000";
            const domain = "https://backend-staging.relokatehr.com/api";
            // API calls
            const getCountries = () => {
                return fetch(`${domain}/countries`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getUniversities = (params = { pageSize: 1000, start: 0 }) => {
                if (!params?.countryCode || !params?.country) {
                    return Promise.reject("Mandatory params not available");
                }
                params.start = params.start ?? 0;
                const url = `${domain}/universities`;
                let query = `?pageSize=${params.pageSize}&countryCode=${params.countryCode}&country=${params.country}&start=${params.start}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getDegrees = (params = { pageSize: 1000, start: 0 }) => {
                if (!params?.countryCode || !params?.country || !params?.degreeTypeId) {
                    return Promise.reject("Mandatory params not available");
                }
                params.start = params.start ?? 0;
                const url = `${domain}/degrees`;
                let query = `?pageSize=${params.pageSize}&countryCode=${params.countryCode}&country=${params.country}&degreeTypeId=${params.degreeTypeId}&start=${params.start}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getDegreeTypes = (params = { pageSize: 1000, start: 0 }) => {
                if (!params?.countryCode || !params?.country) {
                    return Promise.reject("Mandatory params not available");
                }
                params.start = params.start ?? 0;
                const url = `${domain}/degreeTypes`;
                let query = `?pageSize=${params.pageSize}&countryCode=${params.countryCode}&country=${params.country}&start=${params.start}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getDegreeRecognition = (result) => {
                if (!result || !Object.keys(result).length) {
                    return Promise.reject("Empty form");
                }
                if (result.degreeId == null) {
                    return Promise.reject("Mandatory params are not available");
                }
                
                const url = `${domain}/degreeRecognition`;
                let query = `?degreeId=${result.degreeId}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getUniversityRecognition = (result) => {
                if (!result || !Object.keys(result).length) {
                    return Promise.reject("Empty form");
                }
                if (result.universityId == null) {
                    return Promise.reject("Mandatory params are not available");
                }
                
                const url = `${domain}/universityRecognition`;
                let query = `?universityId=${result.universityId}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };

            // API calls massaged for form creator structure
            // These names are to be used in form schema
            const services = {
                getCountries: "getCountries",
                getUniversities: "getUniversities",
                getDegrees: "getDegrees",
                getDegreeTypes: "getDegreeTypes",
                getDegreeRecognition: "getDegreeRecognition",
                getUniversityRecognition: "getUniversityRecognition"
            };
            const serviceHelpers = {
                [services.getCountries]: () => {
                    // return from cache?
                    if (store.countries !== null) {
                        return Promise.resolve([...store.countries]);
                    }
                    // else fetch from api
                    return getCountries()
                        .then((response) => {
                            const options = response.map(item => ({ label: item.name, value: item.code }));
                            // caching in store
                            store.countries = [...options];

                            return options;
                        });
                },
                [services.getUniversities]: (params) => {
                    // country and countryCode
                    const educationCountryOption = params[`${store.reservedKeys.educationCountry}${idAppends.Option}`];
                    if (educationCountryOption) {
                        params.countryCode = educationCountryOption.value;
                        params.country = educationCountryOption.label;
                    }

                    // return from cache? depends on dynamic request params changing
                    if (
                        store.universities
                        && params.countryCode
                        && store.universities.params.countryCode == params.countryCode
                        && !params.start
                    ) {
                        const response = {...store.universities.response, data: [...store.universities.response.data]};
                        return Promise.resolve(response);
                    }

                    return getUniversities(params)
                        .then((response) => {
                            if (!response) {
                                throw new Error('Error fetch data from anabin');
                            }
                            response.data = (response.data ?? []).map(item => ({label: item.university, value: item.uid}));
                            
                            // caching in store
                            if (!params.start || !store.universities) {
                                store.universities = {
                                    params: {...params},
                                    response: {
                                        totalDisplayRecords: 0,
                                        totalResponse: 0,
                                        data: []
                                    }
                                };
                            }
                            store.universities.params = {...params};
                            store.universities.response.data.push(...response.data);
                            
                            return response;
                        });
                },
                [services.getDegrees]: (params) => {
                    // country and countryCode
                    const educationCountryOption = params[`${store.reservedKeys.educationCountry}${idAppends.Option}`];
                    if (educationCountryOption) {
                        params.countryCode = educationCountryOption.value;
                        params.country = educationCountryOption.label;
                    }
                    // degreeTypeId
                    const educationLevel = params[store.reservedKeys.educationLevel];
                    if (educationLevel && educationLevel !== 'undefined') {
                        params.degreeTypeId = educationLevel;
                    }

                    // return from cache?
                    if (
                        store.degrees
                        && params.countryCode
                        && store.degrees.params.countryCode == params.countryCode
                        && store.degrees.params.degreeTypeId == params.degreeTypeId
                        && !params.start
                    ) {
                        const response = {...store.degrees.response, data: [...store.degrees.response.data]};
                        return Promise.resolve(response);
                    }

                    return getDegrees(params)
                        .then((response) => {
                            if (!response) {
                                throw new Error('Error fetch data from anabin');
                            }
                            response.data = (response.data ?? []).map(item => ({label: item.degree, value: item.uid}));

                            // caching in store
                            if (!params.start || !store.degrees) {
                                store.degrees = {
                                    params: {...params},
                                    response: {
                                        totalDisplayRecords: 0,
                                        totalResponse: 0,
                                        data: []
                                    }
                                };
                            }
                            store.degrees.params = {...params};
                            store.degrees.response.data.push(...response.data);

                            return response;
                        });
                },
                [services.getDegreeTypes]: (params) => {
                    // country and countryCode
                    const educationCountryOption = params[`${store.reservedKeys.educationCountry}${idAppends.Option}`];
                    if (educationCountryOption) {
                        params.countryCode = educationCountryOption.value;
                        params.country = educationCountryOption.label;
                    }

                    // return from cache?
                    if (
                        store.degreeTypes
                        && params.countryCode
                        && store.degreeTypes.params.countryCode == params.countryCode
                        && !params.start
                    ) {
                        const response = {...store.degreeTypes.response, data: [...store.degreeTypes.response.data]};
                        return Promise.resolve(response);
                    }

                    return getDegreeTypes(params)
                        .then((response) => {
                            if (!response) {
                                throw new Error('Error fetch data from anabin');
                            }
                            response.data = (response.data ?? []).map(item => ({label: item.degreeType, value: item.uid}));

                            // caching in store
                            if (!params.start || !store.degreeTypes) {
                                store.degreeTypes = {
                                    params: {...params},
                                    response: {
                                        totalDisplayRecords: 0,
                                        totalResponse: 0,
                                        data: []
                                    }
                                };
                            }
                            store.degreeTypes.params = {...params};
                            store.degreeTypes.response.data.push(...response.data);

                            return response;
                        });
                },
                [services.getDegreeRecognition]: (result) => {
                    if (result)
                        result.degreeId = result[`${store.reservedKeys.degree}${idAppends.Option}`]?.value;

                    return getDegreeRecognition(result);
                },
                [services.getUniversityRecognition]: (result) => {
                    if (result)
                        result.universityId = result[`${store.reservedKeys.university}${idAppends.Option}`]?.value;

                    return getUniversityRecognition(result);
                }
            };

            return {
                services,
                serviceHelpers,
                getCountries,
                getUniversities,
                getDegrees,
                getDegreeTypes,
                getDegreeRecognition,
                getUniversityRecognition
            };
        };

        const useComponents = () => {
            // MAPPING
            const components = {
                text: "text",
                select: "select",
                radio: "radio",
                paragraph: "paragraph"
            };
            const componentSlots = {
                [components.select]: {
                    helperText: "helperText"
                }
            };
            const defaultSelectOption = {
                label: 'Select an option',
                value: undefined
            };

            // UTILS
            const createElement = (el, parent) => {
                const element = document.createElement(el);
                parent.appendChild(element);
                return element;
            };
            const syncPoll = (fnToPoll, params, callback, next, catchFn, finallyFn, num = 0) => {
                const finalParams = params ?? {};
                fnToPoll(params) // here params is intentional
                    .then(response => {
                        callback(response, finalParams, num);
                        const nextParams = next ? next(response, finalParams, num) : false;
                        if (nextParams) {
                            syncPoll(fnToPoll, nextParams, callback, next, catchFn, finallyFn, num + 1);
                        }
                    })
                    .catch(catchFn)
                    .finally(() => {
                        finallyFn(finalParams, num);
                    });
            };

            // COMPONENTS
            const createPrompt = ({ type = "success", ...props }, parent) => {
                const prompt = createElement("div", parent);
                prompt.setAttribute("role", "alert");
                prompt.classList.add("alert", `alert-${type}`);
                prompt.innerHTML = props.text;
                return prompt;
            };
            const createButton = ({variant = "btn-primary", ...props}, events, parent) => {
                const { onClick } = events;
                const buttonEl = createElement("button", parent);
                buttonEl.classList.add("btn", variant);
                buttonEl.setAttribute("type", "button");
                buttonEl.innerHTML = props.text;

                if (onClick) {
                    buttonEl.addEventListener('click', onClick);
                }

                return buttonEl;
            };
            const createModal = (props, slots, parent) => {
                const divModal = createElement("div", parent);
                divModal.setAttribute("id", props.id);
                divModal.classList.add("modal", "fade");
                divModal.setAttribute("tabindex", "-1");
                divModal.setAttribute("aria-labelledby", `${props.id}Label`);
                divModal.setAttribute("aria-hidden", "true");

                const divModalDialog = createElement("div", divModal);
                divModalDialog.classList.add("modal-dialog");

                const divModalContent = createElement("div", divModalDialog);
                divModalContent.classList.add("modal-content");

                const divModalHeader = createElement("div", divModalContent);
                divModalHeader.classList.add("modal-header");
                const title = createElement("h1", divModalHeader);
                title.setAttribute("id", `${props.id}Label`);
                title.classList.add("modal-title", "fs-5");
                title.innerHTML = props.title ?? "";
                const close = createElement("button", divModalHeader);
                close.setAttribute("type", "button");
                close.classList.add("btn-close");
                close.setAttribute("data-bs-dismiss", "modal");
                close.setAttribute("aria-label", "Close");

                const divModalBody = createElement("div", divModalContent);
                divModalBody.classList.add("modal-body");
                slots.body && slots.body(props, divModalBody);

                // const divModalFooter = createElement("div", divModalContent);
                // divModalFooter.classList.add("modal-footer");
                // const buttonClose = createElement("button", divModalFooter);
                // buttonClose.setAttribute("type", "button");
                // buttonClose.classList.add("btn", "btn-primary");
                // buttonClose.innerHTML = "Close";
            };

            // FORM COMPONENTS
            const createText = (item, events, value, parent) => {
                const { onChange } = events;
                const input = createElement("input", parent);
                input.classList.add('form-control');
                input.setAttribute("type", "text");
                input.setAttribute("id", item.id);
                if (value != null && value !== '') {
                    input.setAttribute("value", value);
                }
                if (item.props) {
                    if (item.props.placeholder) {
                        input.setAttribute("placeholder", item.props.placeholder);
                    }
                }

                if (onChange) {
                    input.addEventListener('change', () => {
                        onChange(input.value);
                    });
                }

                return input;
            };
            const createParagraph = (item, events, value, parent) => {
                const { onChange } = events;
                const input = createElement("textarea", parent);
                input.classList.add('form-control');
                input.setAttribute("id", item.id);
                if (value != null && value !== '') {
                    input.innerHTML = value;
                }
                if (item.props) {
                    if (item.props.placeholder) {
                        input.setAttribute("placeholder", item.props.placeholder);
                    }
                    input.setAttribute("rows", item.props.rows ?? 5);
                }

                if (onChange) {
                    input.addEventListener('change', () => {
                        onChange(input.value);
                    });
                }

                return input;
            };
            const createSelectOptions = (data = [], value, parent, clearPrevious = true, addDefaultOption = true) => {
                if (clearPrevious) {
                    parent.innerHTML = "";

                    if (!data.length) {
                        const option = createElement("option", parent);
                        option.setAttribute("value", undefined);
                        option.setAttribute("customoption", undefined);
                        option.innerHTML = "No Options Loaded";

                        parent.setAttribute("disabled", true);

                        return;
                    }
                }

                if (addDefaultOption) {
                    data.unshift(defaultSelectOption);
                }

                // to render long lists asynchronously
                let index = 0;
                const pageSize = 100;
                const interval = setInterval(() => {
                    data.slice(index, index + pageSize).forEach((optionItem) => {
                        const option = createElement("option", parent);
                        option.setAttribute("value", optionItem.value);
                        option.setAttribute("customoption", JSON.stringify(optionItem));
                        option.innerHTML = optionItem.label;

                        if (value != null && value !== '' && value == optionItem.value) {
                            parent.setAttribute("value", value);
                            option.setAttribute("selected", true);
                        }
                    });

                    index += pageSize;
                    if (index >= data.length) {
                        clearInterval(interval);
                        parent.removeAttribute("disabled");
                    }
                }, 0);
            };
            const populateSelectOptions = (dataOptions = [], addDefaultOption, events, value, select) => {
                const { onChange, onChangeOption } = events;
                if (Array.isArray(dataOptions)) {
                    createSelectOptions(dataOptions, value, select, true, addDefaultOption);
                    if (onChange) {
                        onChange(select.value);
                    }
                    if (onChangeOption) {
                        const optionStr = select[select.selectedIndex]?.attributes?.customoption?.value;
                        const option = optionStr ? JSON.parse(optionStr) : undefined;
                        onChangeOption(option);
                    }
                } else {
                    const {
                        fetchOptionsFn,
                        params,
                        callbackFn,
                        stopPollingFn
                    } = dataOptions;

                    const callback = (response, localParams = {}, index) => {
                        const dataOptions = callbackFn ? (callbackFn(response, localParams) ?? []) : (response ?? []);
                        createSelectOptions(dataOptions, value, select, !index, addDefaultOption);
                    };
                    const catchFn = () => {
                        createSelectOptions(
                            [],
                            value,
                            select,
                            true
                        );
                    };
                    const finallyFn = (response, localParams, index) => {
                        if (events.onChangeOption) {
                            const optionStr = select[select.selectedIndex]?.attributes?.customoption?.value;
                            const option = (optionStr && optionStr !== 'undefined') ? JSON.parse(optionStr) : undefined;
                            events.onChangeOption(option);
                        }
                    };
                    const onMounted = () => {
                        if (!fetchOptionsFn) {
                            catchFn();
                            return;
                        }
                        const fnToPoll = 

                        select.setAttribute("disabled", "true");
                        const option = createElement("option", select);
                        option.innerHTML = "Loading...";
                        syncPoll(fetchOptionsFn, params ?? {}, callback, stopPollingFn, catchFn, finallyFn);
                    };
                    onMounted();
                }
            };
            const createSelect = (item, events, slots, value, parent) => {
                const { onChange, onChangeOption = () => {} } = events;
                const { helperText } = componentSlots[components.select];
                const select = createElement("select", parent);
                select.setAttribute("id", item.id);
                select.classList.add('form-select');

                populateSelectOptions(item.props.options, item.props.addDefaultOption, events, value, select);

                if (onChange) {
                    select.addEventListener('change', () => {
                        const optionStr = select[select.selectedIndex]?.attributes?.customoption?.value;
                        const option = optionStr ? JSON.parse(optionStr) : undefined;
                        onChangeOption(option);
                        onChange(select.value);
                    });
                }

                slots[helperText] && slots[helperText](item, value, parent);
                
                return select;
            };
            const createRadio = (item, events, value, parent) => {
                const { onChange } = events;
                const radioGroup = [];
                let defaultSelected = null;
                item.props.options.forEach((optionItem, index) => {
                    const radioDiv = createElement("div", parent);
                    radioGroup.push(radioDiv);
                    radioDiv.classList.add("form-check");

                    const radioEl = createElement("input", radioDiv);
                    radioEl.classList.add("form-check-input");
                    radioEl.setAttribute("type", "radio");
                    radioEl.setAttribute("name", item.id);
                    radioEl.setAttribute("id", `${item.id}${index}`);
                    radioEl.setAttribute("value", optionItem.value);

                    if (value != null && value !== '' && value === optionItem.value) {
                        radioEl.setAttribute("checked", true);
                    }

                    const label = createElement("label", radioDiv);
                    label.classList.add("form-check-label");
                    label.setAttribute("for", `${item.id}${index}`);
                    label.innerHTML = optionItem.label;

                    if (onChange) {
                        radioEl.addEventListener("change", () => {
                            onChange(radioEl.value);
                        })
                    }
                });

                return radioGroup;
            };

            // LIBRARY RETURN
            return {
                // constants
                components,
                componentSlots,
                // util
                createElement,
                populateSelectOptions,
                // components
                createButton,
                createPrompt,
                // form components
                createText,
                createParagraph,
                createSelect,
                createSelectOptions,
                createRadio,
                createModal
            };
        };

        const useValidations = () => {
            const { components, createElement } = useComponents();

            const defaultValidationMessage = 'This field requires attention';
            const validators = {
                required: 'required',
                onlyAlphabets: 'onlyAlphabets'
            };
            const validationHelpers = {
                [validators.required]: (value, options) => {
                    return !(value == null || value === '');
                },
                [validators.onlyAlphabets]: (value, options) => {
                    return !(/\d/.test(value));
                }
            };

            const resetValidations = (question) => {
                const fieldValidation = document.getElementById(`${question.id}-validation`);
                if (fieldValidation) {
                    fieldValidation.innerHTML = defaultValidationMessage;
                }
                if (question.type === components.radio) {
                    const fields = document.getElementsByName(question.id);
                    if (fields) {
                        fields.forEach(f => {
                            f.classList.remove('is-invalid');
                        });
                    }
                } else {
                    const field = document.getElementById(question.id);
                    if (field) {
                        field.classList.remove('is-invalid');
                    }
                }
            };
            const setValidations = (question, validation) => {
                if (!validation) {
                    return;
                }

                const fieldValidation = document.getElementById(`${question.id}-validation`);
                if (fieldValidation) {
                    fieldValidation.innerHTML = validation.message ?? defaultValidationMessage;
                }
                if (question.type === components.radio) {
                    const fields = document.getElementsByName(question.id);
                    if (fields) {
                        fields.forEach(f => {
                            f.classList.add('is-invalid');
                        });
                    }
                } else {
                    const field = document.getElementById(question.id);
                    if (field) {
                        field.classList.add('is-invalid');
                    }
                }
            };
            const createValidationUI = (question, inputField, parent) => {
                if (!question.props?.validations?.length) {
                    return;
                }

                let validationParent = parent;
                if (question.type === components.radio) {
                    validationParent = inputField[inputField.length - 1];
                }

                const validationDiv = createElement('div', validationParent);
                validationDiv.setAttribute('id', `${question.id}-validation`);
                validationDiv.classList.add('invalid-feedback');
                validationDiv.innerHTML = defaultValidationMessage;
            };

            const isValid = (form, output) => {
                let result = true;
                form.questions.forEach(item => {
                    if (!item.props?.validations?.length) {
                        return;
                    }
                    // reset field validations for each field
                    resetValidations(item);

                    // don't validate if not visible
                    if (item.visibleOn && Object.keys(item.visibleOn).length) {
                        const quesDiv = document.getElementById(`${item.id}${idAppends.QuestionDiv}`);
                        if (quesDiv && quesDiv.classList.contains("display-none")) {
                            return;
                        }
                    }

                    // run validations in order for a field
                    const value = output[item.id];
                    let validation = null;
                    for (let i = 0; i < item.props.validations.length; i++) {
                        const localValidation = item.props.validations[i];
                        const output = validationHelpers[localValidation.type]
                            ? validationHelpers[localValidation.type](value, localValidation.options)
                            : true;
                        if (!output) {
                            result = false;
                            validation = localValidation;
                            break;
                        }
                    }

                    // show validation on field ui
                    setValidations(item, validation);
                });
                return result;
            };

            return {
                validators,
                isValid,
                createValidationUI
            };
        };

        const useFormRenderer = (
            forms,
            {
                onSubmit = (form, output, next) => { next(); },
                onBack = (next) => {},
                onFinalSubmit = ({
                    backSection,
                    stepSection,
                    questionSection,
                    submitSection
                }) => {},
                onOutputChange = (value, item, forms, output) => {}
            },
            output = {},
            slots = {},
            app
        ) => {
            const {
                components,
                componentSlots,
                createElement,
                createText,
                createParagraph,
                createButton,
                createSelect,
                createPrompt,
                createRadio,
                populateSelectOptions
            } = useComponents();
            const {
                createValidationUI,
                isValid
            } = useValidations();
            const { serviceHelpers } = useServices();

            // HTML elements
            let backSection = null;
            let stepSection = null;
            let questionSection = null;
            let submitSection = null;

            const animationTime = 300;

            const repopulateAffectedSelects = (localValue, localItem, localForms, localOutput) => {
                if (!localItem.affects?.length) {
                    return;
                }

                const affectedItems = {};
                localItem.affects.forEach(id => {
                    // Get all affected field schemas
                    forms.forEach(form => {
                        (form.questions || []).forEach(questionItem => {
                            if (questionItem.id === id) {
                                affectedItems[id] = questionItem;
                            }
                        });
                    });
                });

                if (!Object.keys(affectedItems).length) {
                    return;
                }
                
                Object.keys(affectedItems).forEach(key => {
                    const affectedItem = affectedItems[key];
                    // checks for each affected field which is a select field
                    // and has a promise, which means it will dynamically update
                    // if static array or undefined .. no action required
                    if (affectedItem.type !== components.select) {
                        return;
                    }
                    
                    // need to call apis
                    // prepare apiParams first
                    const { params } = affectedItem.props.options;
                    if (params) {
                        // check if any key in the params are available in the output object
                        // if so then update the latest value in params
                        Object.keys(params).forEach(localKey => {
                            if (output[localKey] == null) {
                                return;
                            }
                            
                            params[localKey] = output[localKey];
                            if (output[`${localKey}${idAppends.Option}`]) {
                                params[`${localKey}${idAppends.Option}`] = output[`${localKey}${idAppends.Option}`];
                            }
                        });
                    }
                    // re-populate the affected select options
                    populateSelectOptions(
                        affectedItem.props.options,
                        affectedItem.props.addDefaultOption,
                        {
                            onChange: (value) => { output[affectedItem.id] = value; },
                            onChangeOption: (value) => { output[`${affectedItem.id}${idAppends.Option}`] = value; }
                        },
                        output[key],
                        document.getElementById(affectedItem.id)
                    );
                });
            };
            // common change event, when any form element is changed
            const onChange = (value, item) => {
                
                // Update output
                output[item.id] = value;

                // Manage affected dependencies
                if (item.affects?.length) {

                    // Check affects dependencies and delete their values (DATA - all types of components)
                    item.affects.forEach(id => {
                        if (item.type === components.radio) {
                            const els = document.getElementsByName(id);
                            if (els?.length) {
                                els.forEach(el => {
                                    el.checked = false;
                                });
                            }
                        } else {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = '';
                            }
                        }

                        output[id] = undefined;
                        output[`${id}${idAppends.Option}`] = undefined;
                    });
                    
                    // Check affects dependencies and repopulate its options (UI - Select)
                    repopulateAffectedSelects(value, item, forms, output);
                }

                // Handle visibleOn mappings
                const map = store.visibleOnMap[item.id];
                if (map) {
                    const elToVisible = document.getElementById(`${map.sourceId}${idAppends.QuestionDiv}`);
                    if (elToVisible) {
                        if (map.value === value) {
                            elToVisible.classList.remove("display-none");
                        } else {
                            elToVisible.classList.add("display-none");
                        }
                    }
                }
                
                onOutputChange(value, item, forms, output);
            };

            const createInput = (item, slots = {}, parent) => {
                const onLocalChange = (value) => {
                    onChange(value, item);
                };
                switch(item.type) {
                    case components.text: {
                        return createText(item, { onChange: onLocalChange }, output[item.id], parent);
                        break;
                    }
                    case components.paragraph: {
                        return createParagraph(item, { onChange: onLocalChange }, output[item.id], parent);
                        break;
                    }
                    case components.select: {
                        if (!Array.isArray(item.props.options) && typeof item.props.options.fetchOptionsFn === 'string') {
                            const helperFn = serviceHelpers[item.props.options.fetchOptionsFn];
                            if (helperFn) {
                                item.props.options.fetchOptionsFn = helperFn;
                            } else {
                                item.props.options = [];
                            }
                        }
                        const mappedSlots = {};
                        Object.keys(componentSlots[components.select] ?? {}).forEach((key) => {
                            if (slots[`${item.id}${key}`]) {
                                mappedSlots[key] = slots[`${item.id}${key}`];
                            }
                        });
                        return createSelect(item, { onChange: onLocalChange, onChangeOption: (optionItem) => { output[`${item.id}${idAppends.Option}`] = optionItem } }, mappedSlots, output[item.id], parent);
                        break;
                    }
                    case components.radio: {
                        return createRadio(item, { onChange: onLocalChange }, output[item.id], parent);
                        break;
                    }
                    default: {
                        return createText(item, { onChange: onLocalChange }, output[item.id], parent);
                        break;
                    }
                }
            };
            const renderQuestion = (question, slots = {}, parent) => {
                const qParentDiv = createElement('div', parent);
                qParentDiv.setAttribute("id", `${question.id}${idAppends.QuestionDiv}`);
                qParentDiv.classList.add('mb-3');
                const qDiv = createElement('label', qParentDiv);
                qDiv.setAttribute('for', question.id);
                qDiv.classList.add('form-label');
                qDiv.innerHTML = question.question;

                const inputField = createInput(question, slots, qParentDiv);

                createValidationUI(question, inputField, qParentDiv);

                slots[`${question.id}Bottom`] && slots[`${question.id}Bottom`](question, qParentDiv);

                return qParentDiv;
            };
            const renderQuestions = ({ id, questions }, slots, parent) => {
                store.visibleOnMap = {};
                const section = createElement('form', parent);
                section.setAttribute("id", id);
                questions.forEach((question) => {
                    const quesDiv = renderQuestion(question, slots, section);

                    // handle generic visibility
                    if (question.visibleOn) {
                        const keys = Object.keys(question.visibleOn);
                        if (keys.length) {
                            // add invisible class
                            if (output[keys[0]] !== question.visibleOn[keys[0]]) {
                                quesDiv.classList.add("display-none");
                            }
                            // maintain map of visible on dependencies
                            store.visibleOnMap[keys[0]] = {
                                value: question.visibleOn[keys[0]],
                                sourceId: question.id
                            };
                        }
                    }
                });
            };
            const renderSteps = (index, total, parent) => {
                const form = forms[index];

                const stepNo = createElement('div', parent);
                stepNo.innerHTML = `Step ${index + 1}/${total}`;
                stepNo.classList.add('step-no');

                const progressBarDiv = createElement('div', parent);
                progressBarDiv.classList.add('position-relative', 'height-6');
                const progressBackground = createElement('span', progressBarDiv);
                progressBackground.classList.add('progress', 'progress-back');
                progressBackground.style.width = '100px';
                const progressBar = createElement('span', progressBarDiv);
                progressBar.classList.add('progress', 'progress-bar');
                progressBar.style.width = `${((index + 1)/total) * 100}px`;

                const stepTitle = createElement('div', parent);
                stepTitle.innerHTML = form.name;

            };
            const renderForm = (form, index, total, slots) => {
                // reset
                backSection.innerHTML = '';
                stepSection.innerHTML = '';
                questionSection.classList.remove('myfade-in');
                setTimeout(() => {
                    questionSection.innerHTML = '';
                }, animationTime);
                submitSection.innerHTML = '';

                // back section
                if (index > 0 && index < total) {
                    const backSpan = createElement('span', backSection);
                    const backIcon = createElement("i", backSpan);
                    backIcon.classList.add("fas", "fa-arrow-left");

                    backSpan.classList.add('cursor-pointer');
                    backSpan.addEventListener("click", () => {
                        onBack(() => {
                            if (index > 0) {
                                index--;
                                renderForm(forms[index], index, total, slots);
                            }
                        });
                    });
                }

                // step section
                if (index < total) {
                    renderSteps(index, total, stepSection);
                }

                // question section
                setTimeout(() => {
                    const title = createElement('h3', questionSection);
                    title.innerHTML = form.title;

                    renderQuestions(form, slots, questionSection);
                    questionSection.classList.add('myfade-in');
                }, animationTime);

                // submit section
                if (index < total) {
                    const onClick = () => {
                        // Validate data
                        if (isValid(form, output)) {
                            onSubmit(form, output, () => {
                                // reset invisible questions on submit
                                const invisibleQuestions = document.getElementsByClassName("display-none");
                                Array.from(invisibleQuestions).forEach((el) => {
                                    if (el.id.includes(idAppends.QuestionDiv)) {
                                        const id = el.id.replace(idAppends.QuestionDiv, "");
                                        output[id] = undefined;
                                        if (output[`${id}${idAppends.Option}`]) {
                                            output[`${id}${idAppends.Option}`] = undefined;
                                        }
                                    }
                                });

                                // navigation
                                if (index < (total - 1)) {
                                    index++;
                                    renderForm(forms[index], index, total, slots);
                                } else {
                                    onFinalSubmit({
                                        backSection,
                                        stepSection,
                                        questionSection,
                                        submitSection
                                    });
                                }
                            });
                        }
                    };
                    const submitBtn = createButton({ text: "Submit" }, { onClick }, submitSection);
                }
            };
            const init = () => {
                backSection = createElement("div", app);
                backSection.classList.add('back-section');

                stepSection = createElement('div', app);
                stepSection.classList.add('step-section');

                questionSection = createElement("div", app);
                questionSection.classList.add('myfade', 'margin-top-20');

                submitSection = createElement("div", app);

                renderForm(forms[0], 0, forms.length, slots);
            };

            return {
                init
            };
        };

        (() => {
            const app = document.getElementById("quizApp");
            if (!app)
                return;

            app.innerHTML = "";

            const {
                components,
                componentSlots,
                createElement,
                populateSelectOptions,
                createPrompt,
                createModal
            } = useComponents();
            const {
                validators,
                isValid
            } = useValidations();
            const { services, serviceHelpers } = useServices();

            const callbackFn = (response) => response.data;
            const stopPollingFn = (response, localParams = {}) => {
                const { start = 0, pageSize = 0 } = localParams;
                const { totalResponse = 0, totalDisplayRecords = 0 } = response;

                const currentRecords = start + pageSize;
                if (currentRecords < totalDisplayRecords) {
                    return {
                        ...localParams,
                        start: currentRecords
                    };
                }
            };

            store.reservedKeys = {
                educationCountry: 'educationCountry',
                educationLevel: 'educationLevel',
                university: 'university',
                degree: 'degree'
            };

            const forms = [
                // {
                //     id: "personalDetails",
                //     name: "Personal Details",
                //     title: "Personal Details",
                //     questions: [
                //         {
                //             id: "surname",
                //             question: "Surname",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Enter your surname",
                //                 validations: [
                //                     { type: validators.required, message: 'Please enter your surname' },
                //                     { type: validators.onlyAlphabets, message: 'Numbers are not allowed' }
                //                 ],
                //             }
                //         },
                //         {
                //             id: "givenName",
                //             question: "Given Name",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Enter your given name"
                //             }
                //         },
                //         {
                //             id: "nationality",
                //             question: "Nationality",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Select your nationality",
                //                 validations: [
                //                     { type: validators.required, message: 'Please enter your nationality' }
                //                 ],
                //             }
                //         },
                //         {
                //             id: "dualCitizenship",
                //             question: "Posesses Dual Citizenship",
                //             type: components.radio,
                //             props: {
                //                 options: [
                //                     { label: "Yes", value: "Yes" },
                //                     { label: "No", value: "No" },
                //                 ],
                //                 validations: [
                //                     { type: validators.required, message: 'Please select an option' },
                //                 ],
                //             }
                //         },
                //         {
                //             id: "citizenshipList",
                //             question: "If yes, please list",
                //             type: components.paragraph,
                //             props: {
                //                 placeholder: "List of citizenships",
                //                 validations: [
                //                     { type: validators.required, message: 'Please enter the list citizenships' }
                //                 ],
                //             },
                //             visibleOn: {
                //                 dualCitizenship: "Yes"
                //             }
                //         },
                //     ]
                // },
                // {
                //     id: "residenceDetails",
                //     name: "Residence Details",
                //     title: "Residence and travel information",
                //     questions: [
                //         {
                //             id: "duration",
                //             question: "Intended duration of residency in Germany",
                //             type: components.text,
                //             props: {
                //                 placeholder: "in years"
                //             }
                //         },
                //         {
                //             id: "previousVisit",
                //             question: "Have you previously visited Germany?",
                //             type: components.radio,
                //             props: {
                //                 options: [
                //                     { label: "Yes", value: "Yes" },
                //                     { label: "No", value: "No" },
                //                 ]
                //             }
                //         },
                //         {
                //             id: "visitDates",
                //             question: "If yes, please list all dates",
                //             type: components.paragraph,
                //             props: {
                //                 placeholder: "enter to and from dates on different lines"
                //             },
                //             visibleOn: {
                //                 previousVisit: "Yes"
                //             }
                //         },
                //         {
                //             id: "currentResidence",
                //             question: "Current place of residence",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Current country and province/state"
                //             }
                //         },
                //     ]
                // },
                // {
                //     id: "professionalDetails",
                //     name: "Professional Details",
                //     title: "Professional background",
                //     questions: [
                //         {
                //             id: "purpose",
                //             question: "Purpose of your visit to Germany",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Enter the purpose"
                //             }
                //         },
                //         {
                //             id: "expertise",
                //             question: "Primary area of expertise",
                //             type: components.text,
                //             props: {
                //                 placeholder: "industry or field"
                //             }
                //         },
                //         {
                //             id: "interestedPositions",
                //             question: "Positions you are interested in (list five)",
                //             type: components.paragraph,
                //             props: {
                //                 placeholder: "list on different lines"
                //             }
                //         },
                //         {
                //             id: "experience",
                //             question: "Total professional experience",
                //             type: components.text,
                //             props: {
                //                 placeholder: "in years"
                //             }
                //         },
                //     ]
                // },
                {
                    id: "educationDetails",
                    name: "Education Details",
                    title: "Educational background",
                    questions: [
                        {
                            id: store.reservedKeys.educationCountry,
                            question: "Country of degree attainment",
                            type: components.select,
                            props: {
                                placeholder: "Select country",
                                options: {
                                    fetchOptionsFn: services.getCountries,
                                },
                                validations: [
                                    // { type: validators.required, message: 'Please select a country' }
                                ],
                            },
                            affects: [
                                store.reservedKeys.educationLevel,
                                store.reservedKeys.university,
                                store.reservedKeys.degree
                            ],
                        },
                        {
                            id: store.reservedKeys.educationLevel,
                            question: "Highest level of education attained",
                            type: components.select,
                            props: {
                                placeholder: "Select level",
                                options: {
                                    fetchOptionsFn: services.getDegreeTypes,
                                    params: {
                                        pageSize: 100,
                                        [store.reservedKeys.educationCountry]: null,
                                        [store.reservedKeys.educationLevel]: null
                                    },
                                    callbackFn,
                                    stopPollingFn
                                },
                                validations: [
                                    // { type: validators.required, message: 'Please select an education level' }
                                ],
                            },
                            affects: [store.reservedKeys.degree],
                        },
                        {
                            id: store.reservedKeys.university,
                            question: "Complete University name",
                            type: components.select,
                            props: {
                                placeholder: "Select university name",
                                options: {
                                    fetchOptionsFn: services.getUniversities,
                                    params: {
                                        pageSize: 500,
                                        [store.reservedKeys.educationCountry]: null
                                    },
                                    callbackFn,
                                    stopPollingFn
                                },
                                validations: [
                                    // { type: validators.required, message: 'Please select a university' }
                                ],
                            },
                            extras: {
                                text: "Unable to find your university? Click here",
                                message: "It might not be listed right now"
                            }
                        },
                        {
                            id: store.reservedKeys.degree,
                            question: "Complete degree name",
                            type: components.select,
                            props: {
                                placeholder: "Select degree name",
                                options: {
                                    fetchOptionsFn: services.getDegrees,
                                    params: {
                                        pageSize: 100,
                                        [store.reservedKeys.educationCountry]: null,
                                        [store.reservedKeys.educationLevel]: null
                                    },
                                    callbackFn,
                                    stopPollingFn
                                },
                                validations: [
                                    // { type: validators.required, message: 'Please select a degree' }
                                ],
                            }
                        },
                        // {
                        //     id: "recognition",
                        //     question: "Has your university degree been officially recognized in Germany?",
                        //     type: components.radio,
                        //     props: {
                        //         options: [
                        //             { label: "Yes", value: "Yes" },
                        //             { label: "No", value: "No" },
                        //         ]
                        //     }
                        // },
                    ]
                },
                {
                    id: "employmentDetails",
                    name: "Employment Details",
                    title: "Employment information",
                    questions: [
                        {
                            id: "germanEmployment",
                            question: "Do you currently hold an employment contract or a confirmed job offer in Germany?",
                            type: components.radio,
                            props: {
                                options: [
                                    { label: "Yes", value: "Yes" },
                                    { label: "No", value: "No" },
                                ],
                                validations: [
                                    { type: validators.required, message: 'Please either of the options' }
                                ],
                            }
                        },
                        {
                            id: "germanCompanyList",
                            question: "If yes, list company name and contact person",
                            type: components.paragraph,
                            props: {
                                placeholder: "Enter on different lines",
                                validations: [
                                    { type: validators.required, message: 'Please enter the required information' }
                                ],
                            },
                            visibleOn: {
                                germanEmployment: "Yes"
                            }
                        },
                        {
                            id: "expectedIncome",
                            question: "Anticipated Gross Income for the Intended Job",
                            type: components.text,
                            props: {
                                placeholder: "enter amount as per annum",
                                validations: [
                                    { type: validators.required, message: 'Please either an amount' }
                                ],
                            },
                            // extras: {
                            //     prompt: `
                            //         For IT professionals and bottleneck professions - eligible
                            //         For Blue card if salary is 39,682.80 or above - eligible
                            //         For other regular occupations they are eligible for Blue Card if salary is 43,800 or above - eligible
                            //     `,
                            // }
                        }
                    ]
                },
            ];
            const output = {};
            
            const spinner = (parent) => {
                const wrapper = createElement("div", parent);
                wrapper.classList.add("lds-ellipsis");
                createElement("div", wrapper);
                createElement("div", wrapper);
                createElement("div", wrapper);
            };

            const onSubmit = (form, output, next) => {
                next();
            };
            const onBack = (next) => {
                next();
            };
            const onFinalSubmit = async () => {
                app.innerHTML = "";
                spinner(app);

                const isDegreeRecognized = serviceHelpers[services.getDegreeRecognition](output);
                const isUniversityRecognized = serviceHelpers[services.getUniversityRecognition](output);
                const result = await Promise.all([isDegreeRecognized, isUniversityRecognized]);

                app.innerHTML = "";
                const resultDiv = createElement("div", app);
                resultDiv.classList.add("margin-top-50");
                if (result[0] && result[1]) {
                    const h1 = createElement("h1", resultDiv);
                    h1.innerHTML = "Congratulations!!"
                    h1.classList.add("text-align-center");

                    const p = createElement("p", resultDiv);
                    p.innerHTML = "Your university and your degree are officially recognised in Germany. Based on the information of your educational background you have provided us you may be eligible for a working visa (Blue Card) in Germany. Please be aware that this information is provided for informational purposes only and is not intended as legal advice. The final  decision rests with the relevant German authorities. For additional assistance with your relocation, your employer can contact us at hello@relokatehr.com. To learn more about different working visas for Germany, please visit ";
                    
                    const makeItInGermanyAnchor = createElement("a", p);
                    makeItInGermanyAnchor.innerHTML = "Make it in Germany";
                    makeItInGermanyAnchor.href = "https://www.make-it-in-germany.com/en/visa-residence/types";

                    p.innerHTML += ".";
                } else {
                    const p = createElement("p", resultDiv);
                    p.innerHTML = "Regrettably, your degree or university is not currently listed as recognized in Germany. Nevertheless, there's no need to worry. If you are an IT professional and can prove a minimum of three years of equivalent professional experience, coupled with an annual salary of at least 41,041.80 (as of 2024), you may still qualify for a working visa (Blue Card). For individuals in other professions, we recommend pursuing the recognition of your degree by the ";

                    const centralOfficeAnchor = createElement("a", p);
                    centralOfficeAnchor.innerHTML = "Central Office for Foreign Education (ZAB)";
                    centralOfficeAnchor.href = "https://www.kmk.org/zab/central-office-for-foreign-education.html";

                    p.innerHTML += "to potentially meet the criteria for a working visa (Blue Card). For detailed information on the recognition process, please visit our ";

                    const relocationGuideAnchor = createElement("a", p);
                    relocationGuideAnchor.innerHTML = "relocation guide";
                    relocationGuideAnchor.href = "https://relokate.notion.site/Degree-recognition-676e5b4529c54b5497e2c63f44810e30";

                    p.innerHTML += ". Please be aware that this information is provided for informational purposes only and is not intended as legal advice. The final decision rests with the relevant German authorities. For more information please refer to the ";
                    
                    const officialAuthorityAnchor = createElement("a", p);
                    officialAuthorityAnchor.innerHTML = "official authority website";
                    officialAuthorityAnchor.href = "https://www.make-it-in-germany.com/en/working-in-germany/recognition/academic-qualifications";

                    p.innerHTML += ".";
                }

            };
            const slots = {
                // expectedIncomeBottom: (question, parent) => {
                //     const promptEl = createPrompt({ text: question.extras.prompt }, parent);
                //     promptEl.classList.add("form-prompt");
                // },
                [
                    `${store.reservedKeys.university}${componentSlots[components.select].helperText}`
                ]: (item, value, parent) => {

                    const anchor = createElement("button", parent);
                    anchor.innerHTML = item.extras.text;
                    anchor.classList.add("helperText", "link-primary");
                    anchor.setAttribute("type", "button");
                    anchor.setAttribute("data-bs-toggle", "modal");
                    anchor.setAttribute("data-bs-target", "#universityMessage");

                    createModal({id: 'universityMessage'}, {
                        body: (props, parent) => {
                            const div = createElement("div", parent);
                            div.setAttribute("style", "padding: 15px");
                            div.innerHTML = item.extras.message;
                        }
                    }, parent);
                }
            };

            const {
                init
            } = useFormRenderer(
                forms,
                {
                    onSubmit,
                    onBack,
                    onFinalSubmit,
                },
                output,
                slots,
                app,
            );
            init();

        })();
    </script>

</body>
</html>