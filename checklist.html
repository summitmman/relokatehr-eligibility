<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <style>
        .lds-ellipsis {
            /* display: inline-block; */
            margin: 80px auto;
            position: relative;
            width: 80px;
            height: 80px;
        }
        .lds-ellipsis div {
            position: absolute;
            top: 33px;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: #444;
            animation-timing-function: cubic-bezier(0, 1, 1, 0);
        }
        .lds-ellipsis div:nth-child(1) {
            left: 8px;
            animation: lds-ellipsis1 0.6s infinite;
        }
        .lds-ellipsis div:nth-child(2) {
            left: 8px;
            animation: lds-ellipsis2 0.6s infinite;
        }
        .lds-ellipsis div:nth-child(3) {
            left: 32px;
            animation: lds-ellipsis2 0.6s infinite;
        }
        .lds-ellipsis div:nth-child(4) {
            left: 56px;
            animation: lds-ellipsis3 0.6s infinite;
        }
        @keyframes lds-ellipsis1 {
            0% {
                transform: scale(0);
            }
            100% {
                transform: scale(1);
            }
        }
        @keyframes lds-ellipsis3 {
            0% {
                transform: scale(1);
            }
            100% {
                transform: scale(0);
            }
        }
        @keyframes lds-ellipsis2 {
            0% {
                transform: translate(0, 0);
            }
            100% {
                transform: translate(24px, 0);
            }
        }
    </style>
    <style>
        .myfade {
            opacity: 0;
            transition: all 0.3s ease;
        }
        .myfade-in {
            opacity: 1;
        }
        .cursor-pointer {
            cursor: pointer;
        }
        .back-section {
            height: 16px;
            margin-top: 10px;
        }
        .progress {
            display: inline-block;
            position: absolute;
            height: 6px;
            border-radius: 10px;
        }
        .height-6 {
            height: 6px;
        }
        .progress-back {
            background-color: #AAA;
        }
        .progress-bar {
            background-color: #444;
        }
        .position-relative {
            position: relative;
        }
        .step-section {
            height: 42px;
            margin-top: 20px;
        }
        .step-no {
            font-size: small;
        }
        .margin-top-20 {
            margin-top: 20px;
        }
        .form-prompt {
            margin-top: 15px;
        }
        .form-label {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="quizApp" class="container">
        <div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
    </div>

    <script src="https://kit.fontawesome.com/6f2a26d215.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <script>
        // @ts-check

        // Global store
        const store = {
            countries: null
        };

        const useServices = () => {
            // API calls
            const getCountries = () => {
                return fetch("http://localhost:3000/countries")
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getUniversities = (params = { pageSize: 1000, start: 0 }) => {
                if (!params?.countryCode || !params?.country) {
                    return Promise.reject("Mandatory params not available");
                }
                params.start = params.start ?? 0;
                const url = 'http://localhost:3000/universities';
                let query = `?pageSize=${params.pageSize}&countryCode=${params.countryCode}&country=${params.country}&start=${params.start}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getDegrees = (params = { pageSize: 1000, start: 0 }) => {
                if (!params?.countryCode || !params?.country || !params?.degreeTypeId) {
                    return Promise.reject("Mandatory params not available");
                }
                params.start = params.start ?? 0;
                const url = 'http://localhost:3000/degrees';
                let query = `?pageSize=${params.pageSize}&countryCode=${params.countryCode}&country=${params.country}&degreeTypeId=${params.degreeTypeId}&start=${params.start}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getDegreeTypes = (params = { pageSize: 1000, start: 0 }) => {
                if (!params?.countryCode || !params?.country) {
                    return Promise.reject("Mandatory params not available");
                }
                params.start = params.start ?? 0;
                const url = 'http://localhost:3000/degreeTypes';
                let query = `?pageSize=${params.pageSize}&countryCode=${params.countryCode}&country=${params.country}&start=${params.start}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };

            // API calls massaged for form creator structure
            // These names are to be used in form schema
            const services = {
                getCountries: "getCountries",
                getUniversities: "getUniversities",
                getDegrees: "getDegrees",
                getDegreeTypes: "getDegreeTypes"
            };
            const serviceHelpers = {
                [services.getCountries]: () => {
                    // return from cache?
                    if (store.countries !== null) {
                        return Promise.resolve([...store.countries]);
                    }
                    // else fetch from api
                    return getCountries()
                        .then((response) => {
                            const options = response.map(item => ({ label: item.name, value: item.code }));
                            // caching in store
                            store.countries = [...options];

                            return options;
                        });
                },
                [services.getUniversities]: (params) => {
                    // country and countryCode
                    const educationCountryOption = params[`${store.reservedKeys.educationCountry}Option`];
                    if (educationCountryOption) {
                        params.countryCode = educationCountryOption.value;
                        params.country = educationCountryOption.label;
                    }

                    // return from cache? depends on dynamic request params changing
                    if (
                        store.universities
                        && params.countryCode
                        && store.universities.params.countryCode == params.countryCode
                        && !params.start
                    ) {
                        const response = {...store.universities.response, data: [...store.universities.response.data]};
                        return Promise.resolve(response);
                    }

                    return getUniversities(params)
                        .then((response) => {
                            if (!response) {
                                throw new Error('Error fetch data from anabin');
                            }
                            response.data = (response.data ?? []).map(item => ({label: item.university, value: item.uid}));
                            
                            // caching in store
                            if (!params.start || !store.universities) {
                                store.universities = {
                                    params: {...params},
                                    response: {
                                        totalDisplayRecords: 0,
                                        totalResponse: 0,
                                        data: []
                                    }
                                };
                            }
                            store.universities.params = {...params};
                            store.universities.response.data.push(...response.data);
                            
                            return response;
                        });
                },
                [services.getDegrees]: (params) => {
                    // country and countryCode
                    const educationCountryOption = params[`${store.reservedKeys.educationCountry}Option`];
                    if (educationCountryOption) {
                        params.countryCode = educationCountryOption.value;
                        params.country = educationCountryOption.label;
                    }
                    // degreeTypeId
                    const educationLevel = params[store.reservedKeys.educationLevel];
                    if (educationLevel && educationLevel !== 'undefined') {
                        params.degreeTypeId = educationLevel;
                    }

                    // return from cache?
                    if (
                        store.degrees
                        && params.countryCode
                        && store.degrees.params.countryCode == params.countryCode
                        && store.degrees.params.degreeTypeId == params.degreeTypeId
                        && !params.start
                    ) {
                        const response = {...store.degrees.response, data: [...store.degrees.response.data]};
                        return Promise.resolve(response);
                    }

                    return getDegrees(params)
                        .then((response) => {
                            if (!response) {
                                throw new Error('Error fetch data from anabin');
                            }
                            response.data = (response.data ?? []).map(item => ({label: item.degree, value: item.uid}));

                            // caching in store
                            if (!params.start || !store.degrees) {
                                store.degrees = {
                                    params: {...params},
                                    response: {
                                        totalDisplayRecords: 0,
                                        totalResponse: 0,
                                        data: []
                                    }
                                };
                            }
                            store.degrees.params = {...params};
                            store.degrees.response.data.push(...response.data);

                            return response;
                        });
                },
                [services.getDegreeTypes]: (params) => {
                    // country and countryCode
                    const educationCountryOption = params[`${store.reservedKeys.educationCountry}Option`];
                    if (educationCountryOption) {
                        params.countryCode = educationCountryOption.value;
                        params.country = educationCountryOption.label;
                    }

                    // return from cache?
                    if (
                        store.degreeTypes
                        && params.countryCode
                        && store.degreeTypes.params.countryCode == params.countryCode
                        && !params.start
                    ) {
                        const response = {...store.degreeTypes.response, data: [...store.degreeTypes.response.data]};
                        return Promise.resolve(response);
                    }

                    return getDegreeTypes(params)
                        .then((response) => {
                            if (!response) {
                                throw new Error('Error fetch data from anabin');
                            }
                            response.data = (response.data ?? []).map(item => ({label: item.degreeType, value: item.uid}));

                            // caching in store
                            if (!params.start || !store.degreeTypes) {
                                store.degreeTypes = {
                                    params: {...params},
                                    response: {
                                        totalDisplayRecords: 0,
                                        totalResponse: 0,
                                        data: []
                                    }
                                };
                            }
                            store.degreeTypes.params = {...params};
                            store.degreeTypes.response.data.push(...response.data);

                            return response;
                        });
                },
            };

            return {
                services,
                serviceHelpers,
                getCountries,
                getUniversities,
                getDegrees,
                getDegreeTypes
            };
        };

        const useComponents = () => {
            // MAPPING
            const components = {
                text: "text",
                select: "select",
                radio: "radio",
                paragraph: "paragraph"
            };
            const defaultSelectOption = {
                label: 'Select an option',
                value: undefined
            };

            // UTILS
            const createElement = (el, parent) => {
                const element = document.createElement(el);
                parent.appendChild(element);
                return element;
            };
            const syncPoll = (fnToPoll, params, callback, next, catchFn, finallyFn, num = 0) => {
                const finalParams = params ?? {};
                fnToPoll(params) // here params is intentional
                    .then(response => {
                        callback(response, finalParams, num);
                        const nextParams = next ? next(response, finalParams, num) : false;
                        if (nextParams) {
                            syncPoll(fnToPoll, nextParams, callback, next, catchFn, finallyFn, num + 1);
                        }
                    })
                    .catch(catchFn)
                    .finally(() => {
                        finallyFn(finalParams, num);
                    });
            };

            // COMPONENTS
            const createPrompt = (str, parent, type="success") => {
                const prompt = createElement("div", parent);
                prompt.setAttribute("role", "alert");
                prompt.classList.add("alert", `alert-${type}`);
                prompt.innerHTML = str;
                return prompt;
            };
            const createButton = (str, events, parent) => {
                const { onClick } = events;
                const buttonEl = createElement("button", parent);
                buttonEl.classList.add("btn", "btn-primary");
                buttonEl.setAttribute("type", "button");
                buttonEl.innerHTML = str;

                if (onClick) {
                    buttonEl.addEventListener('click', onClick);
                }

                return buttonEl;
            };

            // FORM COMPONENTS
            const createText = (item, events, value, parent) => {
                const { onChange } = events;
                const input = createElement("input", parent);
                input.classList.add('form-control');
                input.setAttribute("type", "text");
                input.setAttribute("id", item.id);
                if (value != null && value !== '') {
                    input.setAttribute("value", value);
                }
                if (item.props) {
                    if (item.props.placeholder) {
                        input.setAttribute("placeholder", item.props.placeholder);
                    }
                }

                if (onChange) {
                    input.addEventListener('change', () => {
                        onChange(input.value);
                    });
                }

                return input;
            };
            const createParagraph = (item, events, value, parent) => {
                const { onChange } = events;
                const input = createElement("textarea", parent);
                input.classList.add('form-control');
                input.setAttribute("id", item.id);
                if (value != null && value !== '') {
                    input.innerHTML = value;
                }
                if (item.props) {
                    if (item.props.placeholder) {
                        input.setAttribute("placeholder", item.props.placeholder);
                    }
                    input.setAttribute("rows", item.props.rows ?? 5);
                }

                if (onChange) {
                    input.addEventListener('change', () => {
                        onChange(input.value);
                    });
                }

                return input;
            };
            const createSelectOptions = (data = [], value, parent, clearPrevious = true, addDefaultOption = true) => {
                if (clearPrevious) {
                    parent.innerHTML = "";

                    if (!data.length) {
                        const option = createElement("option", parent);
                        option.setAttribute("value", undefined);
                        option.setAttribute("customoption", undefined);
                        option.innerHTML = "No Options Loaded";

                        parent.setAttribute("disabled", true);

                        return;
                    }
                }

                if (addDefaultOption) {
                    data.unshift(defaultSelectOption);
                }

                // to render long lists asynchronously
                let index = 0;
                const pageSize = 100;
                const interval = setInterval(() => {
                    data.slice(index, index + pageSize).forEach((optionItem) => {
                        const option = createElement("option", parent);
                        option.setAttribute("value", optionItem.value);
                        option.setAttribute("customoption", JSON.stringify(optionItem));
                        option.innerHTML = optionItem.label;

                        if (value != null && value !== '' && value == optionItem.value) {
                            parent.setAttribute("value", value);
                            option.setAttribute("selected", true);
                        }
                    });

                    index += pageSize;
                    if (index >= data.length) {
                        clearInterval(interval);
                        parent.removeAttribute("disabled");
                    }
                }, 0);
            };
            const populateSelectOptions = (dataOptions = [], addDefaultOption, events, value, select) => {
                const { onChange, onChangeOption } = events;
                if (Array.isArray(dataOptions)) {
                    createSelectOptions(dataOptions, value, select, true, addDefaultOption);
                    if (onChange) {
                        onChange(select.value);
                    }
                    if (onChangeOption) {
                        const optionStr = select[select.selectedIndex]?.attributes?.customoption?.value;
                        const option = optionStr ? JSON.parse(optionStr) : undefined;
                        onChangeOption(option);
                    }
                } else {
                    const {
                        fetchOptionsFn,
                        params,
                        callbackFn,
                        stopPollingFn
                    } = dataOptions;

                    const callback = (response, localParams = {}, index) => {
                        const dataOptions = callbackFn ? (callbackFn(response, localParams) ?? []) : (response ?? []);
                        createSelectOptions(dataOptions, value, select, !index, addDefaultOption);
                    };
                    const catchFn = () => {
                        createSelectOptions(
                            [],
                            value,
                            select,
                            true
                        );
                    };
                    const finallyFn = (response, localParams, index) => {
                        if (events.onChangeOption) {
                            const optionStr = select[select.selectedIndex]?.attributes?.customoption?.value;
                            const option = (optionStr && optionStr !== 'undefined') ? JSON.parse(optionStr) : undefined;
                            events.onChangeOption(option);
                        }
                    };
                    const onMounted = () => {
                        if (!fetchOptionsFn) {
                            catchFn();
                            return;
                        }
                        const fnToPoll = 

                        select.setAttribute("disabled", "true");
                        const option = createElement("option", select);
                        option.innerHTML = "Loading...";
                        syncPoll(fetchOptionsFn, params ?? {}, callback, stopPollingFn, catchFn, finallyFn);
                    };
                    onMounted();
                }
            };
            const createSelect = (item, events, value, parent) => {
                const { onChange, onChangeOption = () => {} } = events;
                const select = createElement("select", parent);
                select.setAttribute("id", item.id);
                select.classList.add('form-select');

                populateSelectOptions(item.props.options, item.props.addDefaultOption, events, value, select);

                if (onChange) {
                    select.addEventListener('change', () => {
                        const optionStr = select[select.selectedIndex]?.attributes?.customoption?.value;
                        const option = optionStr ? JSON.parse(optionStr) : undefined;
                        onChangeOption(option);
                        onChange(select.value);
                    });
                }
                
                return select;
            };
            const createRadio = (item, events, value, parent) => {
                const { onChange } = events;
                const radioGroup = [];
                let defaultSelected = null;
                item.props.options.forEach((optionItem, index) => {
                    const radioDiv = createElement("div", parent);
                    radioGroup.push(radioDiv);
                    radioDiv.classList.add("form-check");

                    const radioEl = createElement("input", radioDiv);
                    radioEl.classList.add("form-check-input");
                    radioEl.setAttribute("type", "radio");
                    radioEl.setAttribute("name", item.id);
                    radioEl.setAttribute("id", `${item.id}${index}`);
                    radioEl.setAttribute("value", optionItem.value);

                    if (value != null && value !== '' && value === optionItem.value) {
                        radioEl.setAttribute("checked", true);
                    }

                    const label = createElement("label", radioDiv);
                    label.classList.add("form-check-label");
                    label.setAttribute("for", `${item.id}${index}`);
                    label.innerHTML = optionItem.label;

                    if (onChange) {
                        radioEl.addEventListener("change", () => {
                            onChange(radioEl.value);
                        })
                    }
                });

                return radioGroup;
            };

            // LIBRARY RETURN
            return {
                // constants
                components,
                // util
                createElement,
                populateSelectOptions,
                // components
                createButton,
                createPrompt,
                // form components
                createText,
                createParagraph,
                createSelect,
                createSelectOptions,
                createRadio
            };
        };

        const useValidations = () => {
            const { components, createElement } = useComponents();

            const defaultValidationMessage = 'This field requires attention';
            const validators = {
                required: 'required',
                onlyAlphabets: 'onlyAlphabets'
            };
            const validationHelpers = {
                [validators.required]: (value, options) => {
                    return !(value == null || value === '');
                },
                [validators.onlyAlphabets]: (value, options) => {
                    return !(/\d/.test(value));
                }
            };

            const resetValidations = (question) => {
                const fieldValidation = document.getElementById(`${question.id}-validation`);
                if (fieldValidation) {
                    fieldValidation.innerHTML = defaultValidationMessage;
                }
                if (question.type === components.radio) {
                    const fields = document.getElementsByName(question.id);
                    if (fields) {
                        fields.forEach(f => {
                            f.classList.remove('is-invalid');
                        });
                    }
                } else {
                    const field = document.getElementById(question.id);
                    if (field) {
                        field.classList.remove('is-invalid');
                    }
                }
            };
            const setValidations = (question, validation) => {
                if (!validation) {
                    return;
                }

                const fieldValidation = document.getElementById(`${question.id}-validation`);
                if (fieldValidation) {
                    fieldValidation.innerHTML = validation.message ?? defaultValidationMessage;
                }
                if (question.type === components.radio) {
                    const fields = document.getElementsByName(question.id);
                    if (fields) {
                        fields.forEach(f => {
                            f.classList.add('is-invalid');
                        });
                    }
                } else {
                    const field = document.getElementById(question.id);
                    if (field) {
                        field.classList.add('is-invalid');
                    }
                }
            };
            const createValidationUI = (question, inputField, parent) => {
                if (!question.props?.validations?.length) {
                    return;
                }

                let validationParent = parent;
                if (question.type === components.radio) {
                    validationParent = inputField[inputField.length - 1];
                }

                const validationDiv = createElement('div', validationParent);
                validationDiv.setAttribute('id', `${question.id}-validation`);
                validationDiv.classList.add('invalid-feedback');
                validationDiv.innerHTML = defaultValidationMessage;
            };

            const isValid = (form, output) => {
                let result = true;
                form.questions.forEach(item => {
                    if (!item.props?.validations?.length) {
                        return;
                    }
                    // reset field validations for each field
                    resetValidations(item);

                    // run validations in order for a field
                    const value = output[item.id];
                    let validation = null;
                    for (let i = 0; i < item.props.validations.length; i++) {
                        const localValidation = item.props.validations[i];
                        const output = validationHelpers[localValidation.type]
                            ? validationHelpers[localValidation.type](value, localValidation.options)
                            : true;
                        if (!output) {
                            result = false;
                            validation = localValidation;
                            break;
                        }
                    }

                    // show validation on field ui
                    setValidations(item, validation);
                });
                return result;
            };

            return {
                validators,
                isValid,
                createValidationUI
            };
        };

        const useFormRenderer = (
            forms,
            {
                onSubmit = (form, output, next) => { next(); },
                onBack = (next) => {},
                onFinalSubmit = ({
                    backSection,
                    stepSection,
                    questionSection,
                    submitSection
                }) => {},
                onOutputChange = (value, item, forms, output) => {}
            },
            output = {},
            app
        ) => {
            const {
                components,
                createElement,
                createText,
                createParagraph,
                createButton,
                createSelect,
                createPrompt,
                createRadio,
                populateSelectOptions
            } = useComponents();
            const {
                createValidationUI,
                isValid
            } = useValidations();
            const { serviceHelpers } = useServices();

            // HTML elements
            let backSection = null;
            let stepSection = null;
            let questionSection = null;
            let submitSection = null;

            const animationTime = 300;

            const repopulateAffectedSelects = (localValue, localItem, localForms, localOutput) => {
                if (!localItem.affects?.length) {
                    return;
                }

                const affectedItems = {};
                localItem.affects.forEach(id => {
                    // Get all affected field schemas
                    forms.forEach(form => {
                        (form.questions || []).forEach(questionItem => {
                            if (questionItem.id === id) {
                                affectedItems[id] = questionItem;
                            }
                        });
                    });
                });

                if (!Object.keys(affectedItems).length) {
                    return;
                }
                
                Object.keys(affectedItems).forEach(key => {
                    const affectedItem = affectedItems[key];
                    // checks for each affected field which is a select field
                    // and has a promise, which means it will dynamically update
                    // if static array or undefined .. no action required
                    if (affectedItem.type !== components.select) {
                        return;
                    }
                    
                    // need to call apis
                    // prepare apiParams first
                    const { params } = affectedItem.props.options;
                    if (params) {
                        // check if any key in the params are available in the output object
                        // if so then update the latest value in params
                        Object.keys(params).forEach(localKey => {
                            if (output[localKey] == null) {
                                return;
                            }
                            
                            params[localKey] = output[localKey];
                            if (output[`${localKey}Option`]) {
                                params[`${localKey}Option`] = output[`${localKey}Option`];
                            }
                        });
                    }
                    // re-populate the affected select options
                    populateSelectOptions(
                        affectedItem.props.options,
                        affectedItem.props.addDefaultOption,
                        {
                            onChange: (value) => { output[affectedItem.id] = value; },
                            onChangeOption: (value) => { output[`${affectedItem.id}Option`] = value; }
                        },
                        output[key],
                        document.getElementById(affectedItem.id)
                    );
                });
            };
            // common change event, when any form element is changed
            const onChange = (value, item) => {
                // Update output
                output[item.id] = value;
                // Manage affected dependencies
                if (item.affects?.length) {
                    // Check affects dependencies and delete their values (DATA - all types of components)
                    item.affects.forEach(id => {
                        if (item.type === components.radio) {
                            const els = document.getElementsByName(id);
                            if (els?.length) {
                                els.forEach(el => {
                                    el.checked = false;
                                });
                            }
                        } else {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = '';
                            }
                        }

                        output[id] = undefined;
                        output[`${id}Option`] = undefined;
                    });
                    // Check affects dependencies and repopulate its options (UI - Select)
                    repopulateAffectedSelects(value, item, forms, output);
                }
                onOutputChange(value, item, forms, output);
            };

            const createInput = (item, parent) => {
                const onLocalChange = (value) => {
                    onChange(value, item);
                };
                switch(item.type) {
                    case components.text: {
                        return createText(item, { onChange: onLocalChange }, output[item.id], parent);
                        break;
                    }
                    case components.paragraph: {
                        return createParagraph(item, { onChange: onLocalChange }, output[item.id], parent);
                        break;
                    }
                    case components.select: {
                        if (!Array.isArray(item.props.options) && typeof item.props.options.fetchOptionsFn === 'string') {
                            const helperFn = serviceHelpers[item.props.options.fetchOptionsFn];
                            if (helperFn) {
                                item.props.options.fetchOptionsFn = helperFn;
                            } else {
                                item.props.options = [];
                            }
                        }
                        return createSelect(item, { onChange: onLocalChange, onChangeOption: (optionItem) => { output[`${item.id}Option`] = optionItem } }, output[item.id], parent);
                        break;
                    }
                    case components.radio: {
                        return createRadio(item, { onChange: onLocalChange }, output[item.id], parent);
                        break;
                    }
                    default: {
                        return createText(item, { onChange: onLocalChange }, output[item.id], parent);
                        break;
                    }
                }
            };
            const renderQuestion = (question, parent) => {
                const qParentDiv = createElement('div', parent);
                qParentDiv.classList.add('mb-3');
                const qDiv = createElement('label', qParentDiv);
                qDiv.setAttribute('for', question.id);
                qDiv.classList.add('form-label');
                qDiv.innerHTML = question.question;

                const inputField = createInput(question, qParentDiv);

                createValidationUI(question, inputField, qParentDiv);

                if (question.prompt) {
                    const promptEl = createPrompt(question.prompt, qParentDiv);
                    promptEl.classList.add("form-prompt");
                }
            };
            const renderQuestions = ({ id, questions }, parent) => {
                const section = createElement('form', parent);
                section.setAttribute("id", id);
                questions.forEach((question) => {
                    renderQuestion(question, section);
                });
            };
            const renderSteps = (index, total, parent) => {
                const form = forms[index];

                const stepNo = createElement('div', parent);
                stepNo.innerHTML = `Step ${index + 1}/${total}`;
                stepNo.classList.add('step-no');

                const progressBarDiv = createElement('div', parent);
                progressBarDiv.classList.add('position-relative', 'height-6');
                const progressBackground = createElement('span', progressBarDiv);
                progressBackground.classList.add('progress', 'progress-back');
                progressBackground.style.width = '100px';
                const progressBar = createElement('span', progressBarDiv);
                progressBar.classList.add('progress', 'progress-bar');
                progressBar.style.width = `${((index + 1)/total) * 100}px`;

                const stepTitle = createElement('div', parent);
                stepTitle.innerHTML = form.name;

            };
            const renderForm = (form, index, total) => {
                // reset
                backSection.innerHTML = '';
                stepSection.innerHTML = '';
                questionSection.classList.remove('myfade-in');
                setTimeout(() => {
                    questionSection.innerHTML = '';
                }, animationTime);
                submitSection.innerHTML = '';

                // back section
                if (index > 0 && index < total) {
                    const backSpan = createElement('span', backSection);
                    const backIcon = createElement("i", backSpan);
                    backIcon.classList.add("fas", "fa-arrow-left");

                    backSpan.classList.add('cursor-pointer');
                    backSpan.addEventListener("click", () => {
                        onBack(() => {
                            if (index > 0) {
                                index--;
                                renderForm(forms[index], index, total);
                            }
                        });
                    });
                }

                // step section
                if (index < total) {
                    renderSteps(index, total, stepSection);
                }

                // question section
                setTimeout(() => {
                    const title = createElement('h3', questionSection);
                    title.innerHTML = form.title;

                    renderQuestions(form, questionSection);
                    questionSection.classList.add('myfade-in');
                }, animationTime);

                // submit section
                if (index < total) {
                    const onClick = () => {
                        // Validate data
                        if (isValid(form, output)) {
                            onSubmit(form, output, () => {
                                if (index < (total - 1)) {
                                    index++;
                                    renderForm(forms[index], index, total);
                                } else {
                                    onFinalSubmit({
                                        backSection,
                                        stepSection,
                                        questionSection,
                                        submitSection
                                    });
                                }
                            });
                        }
                    };
                    const submitBtn = createButton("Submit", { onClick }, submitSection);
                }
            };
            const init = () => {
                backSection = createElement("div", app);
                backSection.classList.add('back-section');

                stepSection = createElement('div', app);
                stepSection.classList.add('step-section');

                questionSection = createElement("div", app);
                questionSection.classList.add('myfade', 'margin-top-20');

                submitSection = createElement("div", app);

                renderForm(forms[0], 0, forms.length);
            };

            return {
                init
            };
        };

        (() => {
            const app = document.getElementById("quizApp");
            if (!app)
                return;

            app.innerHTML = "";

            const {
                components,
                createElement,
                populateSelectOptions
            } = useComponents();
            const {
                validators,
                isValid
            } = useValidations();
            const { services } = useServices();

            const callbackFn = (response) => response.data;
            const stopPollingFn = (response, localParams = {}) => {
                const { start = 0, pageSize = 0 } = localParams;
                const { totalResponse = 0, totalDisplayRecords = 0 } = response;

                const currentRecords = start + pageSize;
                if (currentRecords < totalDisplayRecords) {
                    return {
                        ...localParams,
                        start: currentRecords
                    };
                }
            };

            store.reservedKeys = {
                educationCountry: 'educationCountry',
                educationLevel: 'educationLevel',
                university: 'university',
                degree: 'degree'
            };

            const forms = [
                // {
                //     id: "personalDetails",
                //     name: "Personal Details",
                //     title: "Personal Details",
                //     questions: [
                //         {
                //             id: "surname",
                //             question: "Surname",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Enter your surname",
                //                 validations: [
                //                     { type: validators.required, message: 'Please enter your surname' },
                //                     { type: validators.onlyAlphabets, message: 'Numbers are not allowed' }
                //                 ],
                //             }
                //         },
                //         {
                //             id: "givenName",
                //             question: "Given Name",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Enter your given name"
                //             }
                //         },
                //         {
                //             id: "nationality",
                //             question: "Nationality",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Select your nationality",
                //                 validations: [
                //                     { type: validators.required, message: 'Please enter your nationality' }
                //                 ],
                //             }
                //         },
                //         {
                //             id: "dualCitizenship",
                //             question: "Posesses Dual Citizenship",
                //             type: components.radio,
                //             props: {
                //                 options: [
                //                     { label: "Yes", value: "Yes" },
                //                     { label: "No", value: "No" },
                //                 ],
                //                 validations: [
                //                     { type: validators.required, message: 'Please select an option' },
                //                 ],
                //             }
                //         },
                //         {
                //             id: "citizenshipList",
                //             question: "If yes, please list",
                //             type: components.paragraph,
                //             props: {
                //                 placeholder: "List of citizenships",
                //                 validations: [
                //                     { type: validators.required, message: 'Please enter the list citizenships' }
                //                 ],
                //             }
                //         },
                //     ]
                // },
                // {
                //     id: "residenceDetails",
                //     name: "Residence Details",
                //     title: "Residence and travel information",
                //     questions: [
                //         {
                //             id: "duration",
                //             question: "Intended duration of residency in Germany",
                //             type: components.text,
                //             props: {
                //                 placeholder: "in years"
                //             }
                //         },
                //         {
                //             id: "previousVisit",
                //             question: "Have you previously visited Germany?",
                //             type: components.radio,
                //             props: {
                //                 options: [
                //                     { label: "Yes", value: "Yes" },
                //                     { label: "No", value: "No" },
                //                 ]
                //             }
                //         },
                //         {
                //             id: "visitDates",
                //             question: "If yes, please list all dates",
                //             type: components.paragraph,
                //             props: {
                //                 placeholder: "enter to and from dates on different lines"
                //             }
                //         },
                //         {
                //             id: "currentResidence",
                //             question: "Current place of residence",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Current country and province/state"
                //             }
                //         },
                //     ]
                // },
                // {
                //     id: "professionalDetails",
                //     name: "Professional Details",
                //     title: "Professional background",
                //     questions: [
                //         {
                //             id: "purpose",
                //             question: "Purpose of your visit to Germany",
                //             type: components.text,
                //             props: {
                //                 placeholder: "Enter the purpose"
                //             }
                //         },
                //         {
                //             id: "expertise",
                //             question: "Primary area of expertise",
                //             type: components.text,
                //             props: {
                //                 placeholder: "industry or field"
                //             }
                //         },
                //         {
                //             id: "interestedPositions",
                //             question: "Positions you are interested in (list five)",
                //             type: components.paragraph,
                //             props: {
                //                 placeholder: "list on different lines"
                //             }
                //         },
                //         {
                //             id: "experience",
                //             question: "Total professional experience",
                //             type: components.text,
                //             props: {
                //                 placeholder: "in years"
                //             }
                //         },
                //     ]
                // },
                {
                    id: "educationDetails",
                    name: "Education Details",
                    title: "Educational background",
                    questions: [
                        {
                            id: store.reservedKeys.educationCountry,
                            question: "Country of degree attainment",
                            type: components.select,
                            props: {
                                placeholder: "Select country",
                                options: {
                                    fetchOptionsFn: services.getCountries,
                                }
                            },
                            affects: [
                                store.reservedKeys.educationLevel,
                                store.reservedKeys.university,
                                store.reservedKeys.degree
                            ]
                        },
                        {
                            id: store.reservedKeys.educationLevel,
                            question: "Highest level of education attained",
                            type: components.select,
                            props: {
                                placeholder: "Select level",
                                options: {
                                    fetchOptionsFn: services.getDegreeTypes,
                                    params: {
                                        pageSize: 100,
                                        [store.reservedKeys.educationCountry]: null,
                                        [store.reservedKeys.educationLevel]: null
                                    },
                                    callbackFn,
                                    stopPollingFn
                                },
                            },
                            affects: [store.reservedKeys.degree]
                        },
                        {
                            id: store.reservedKeys.university,
                            question: "Complete University name",
                            type: components.select,
                            props: {
                                placeholder: "Select university name",
                                options: {
                                    fetchOptionsFn: services.getUniversities,
                                    params: {
                                        pageSize: 500,
                                        [store.reservedKeys.educationCountry]: null
                                    },
                                    callbackFn,
                                    stopPollingFn
                                },
                            }
                        },
                        {
                            id: store.reservedKeys.degree,
                            question: "Complete degree name",
                            type: components.select,
                            props: {
                                placeholder: "Select degree name",
                                options: {
                                    fetchOptionsFn: services.getDegrees,
                                    params: {
                                        pageSize: 100,
                                        [store.reservedKeys.educationCountry]: null,
                                        [store.reservedKeys.educationLevel]: null
                                    },
                                    callbackFn,
                                    stopPollingFn
                                },
                            }
                        },
                        {
                            id: "recognition",
                            question: "Has your university degree been officially recognized in Germany?",
                            type: components.radio,
                            props: {
                                options: [
                                    { label: "Yes", value: "Yes" },
                                    { label: "No", value: "No" },
                                ]
                            }
                        },
                    ]
                },
                {
                    id: "employmentDetails",
                    name: "Employment Details",
                    title: "Employment information",
                    questions: [
                        {
                            id: "germanEmployment",
                            question: "Do you currently hold an employment contract or a confirmed job offer in Germany?",
                            type: components.radio,
                            props: {
                                options: [
                                    { label: "Yes", value: "Yes" },
                                    { label: "No", value: "No" },
                                ]
                            }
                        },
                        {
                            id: "germanCompanyList",
                            question: "If yes, list company name and contact person",
                            type: components.paragraph,
                            props: {
                                placeholder: "Enter on different lines"
                            }
                        },
                        {
                            id: "expectedIncome",
                            question: "Anticipated Gross Income for the Intended Job",
                            prompt: `
                                For IT professionals and bottleneck professions - eligible
                                For Blue card if salary is €39,682.80 or above - eligible
                                For other regular occupations they are eligible for Blue Card if salary is €43,800 or above - eligible
                            `,
                            type: components.text,
                            props: {
                                placeholder: "enter amount as per annum",
                            }
                        }
                    ]
                },
            ];
            const output = {};

            const onSubmit = (form, output, next) => {
                next();
            };
            const onBack = (next) => {
                next();
            };
            const onFinalSubmit = ({
                backSection,
                stepSection,
                questionSection,
                submitSection
            }) => {
                backSection.innerHTML = '';
                stepSection.innerHTML = '';
                questionSection.innerHTML = 'Thank you for filling the survey';
                submitSection.innerHTML = '';
            };

            const {
                init
            } = useFormRenderer(
                forms,
                {
                    onSubmit,
                    onBack,
                    onFinalSubmit,
                },
                output,
                app,
            );
            init();

        })();
    </script>
</body>
</html>