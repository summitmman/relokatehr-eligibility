<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <style>
        .lds-ellipsis {
            /* display: inline-block; */
            margin: 80px auto;
            position: relative;
            width: 80px;
            height: 80px;
        }
        .lds-ellipsis div {
            position: absolute;
            top: 33px;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: #444;
            animation-timing-function: cubic-bezier(0, 1, 1, 0);
        }
        .lds-ellipsis div:nth-child(1) {
            left: 8px;
            animation: lds-ellipsis1 0.6s infinite;
        }
        .lds-ellipsis div:nth-child(2) {
            left: 8px;
            animation: lds-ellipsis2 0.6s infinite;
        }
        .lds-ellipsis div:nth-child(3) {
            left: 32px;
            animation: lds-ellipsis2 0.6s infinite;
        }
        .lds-ellipsis div:nth-child(4) {
            left: 56px;
            animation: lds-ellipsis3 0.6s infinite;
        }
        @keyframes lds-ellipsis1 {
            0% {
                transform: scale(0);
            }
            100% {
                transform: scale(1);
            }
        }
        @keyframes lds-ellipsis3 {
            0% {
                transform: scale(1);
            }
            100% {
                transform: scale(0);
            }
        }
        @keyframes lds-ellipsis2 {
            0% {
                transform: translate(0, 0);
            }
            100% {
                transform: translate(24px, 0);
            }
        }
    </style>
    <style>
        .myfade {
            opacity: 0;
            transition: all 0.3s ease;
        }
        .myfade-in {
            opacity: 1;
        }
        .cursor-pointer {
            cursor: pointer;
        }
        .back-section {
            height: 16px;
            margin-top: 10px;
        }
        .progress {
            display: inline-block;
            position: absolute;
            height: 6px;
            border-radius: 10px;
        }
        .height-6 {
            height: 6px;
        }
        .progress-back {
            background-color: #AAA;
        }
        .progress-bar {
            background-color: #444;
        }
        .position-relative {
            position: relative;
        }
        .step-section {
            height: 42px;
            margin-top: 20px;
        }
        .step-no {
            font-size: small;
        }
        .margin-top-20 {
            margin-top: 20px;
        }
        .form-prompt {
            margin-top: 15px;
        }
        .form-label {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="quizApp" class="container">
        <div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
    </div>

    <script src="https://kit.fontawesome.com/6f2a26d215.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <script>
        // @ts-check

        // Global store
        const store = {
            countries: null
        };

        const useServices = () => {
            // API calls
            const getCountries = () => {
                return fetch("http://localhost:3000/countries")
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getUniversities = (params = { pageSize: 1000, start: 0 }) => {
                if (!params?.countryCode || !params?.country) {
                    return Promise.reject("Mandatory params not available");
                }
                params.start = params.start ?? 0;
                const url = 'http://localhost:3000/universities';
                let query = `?pageSize=${params.pageSize}&countryCode=${params.countryCode}&country=${params.country}&start=${params.start}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getDegrees = (params = { pageSize: 1000, start: 0 }) => {
                if (!params?.countryCode || !params?.country || !params?.degreeTypeId) {
                    return Promise.reject("Mandatory params not available");
                }
                params.start = params.start ?? 0;
                const url = 'http://localhost:3000/degrees';
                let query = `?pageSize=${params.pageSize}&countryCode=${params.countryCode}&country=${params.country}&degreeTypeId=${params.degreeTypeId}&start=${params.start}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };
            const getDegreeTypes = (params = { pageSize: 1000, start: 0 }) => {
                if (!params?.countryCode || !params?.country) {
                    return Promise.reject("Mandatory params not available");
                }
                params.start = params.start ?? 0;
                const url = 'http://localhost:3000/degreeTypes';
                let query = `?pageSize=${params.pageSize}&countryCode=${params.countryCode}&country=${params.country}&start=${params.start}`;
                return fetch(`${url}${query}`)
                    .then((response) => response.json())
                    .then((response) => {
                        return response;
                    });
            };

            // API calls massaged for form creator structure
            // These names are to be used in form schema
            const services = {
                getCountries: "getCountries",
                getUniversities: "getUniversities",
                getDegrees: "getDegrees",
                getDegreeTypes: "getDegreeTypes"
            };
            const serviceHelpers = {
                [services.getCountries]: () => {
                    // cached data for countries
                    if (store.countries !== null) {
                        return Promise.resolve(store.countries).then(response => {
                            return response.map(item => ({ label: item.name, value: item.code }));
                        });
                    }
                    // else fetch from api
                    return getCountries()
                        .then((response) => {
                            store.countries = response;
                            return {
                                data: response.map(item => ({ label: item.name, value: item.code }))
                            };
                        });
                },
                [services.getUniversities]: (params) => {
                    return getUniversities(params)
                        .then((response) => {
                            if (!response) {
                                throw new Error('Error fetch data from anabin');
                            }
                            response.data = (response.data ?? []).map(item => ({label: item.university, value: item.uid}))
                            return response;
                        });
                },
                [services.getDegrees]: (params) => {
                    return getDegrees(params)
                        .then((response) => {
                            if (!response) {
                                throw new Error('Error fetch data from anabin');
                            }
                            response.data = (response.data ?? []).map(item => ({label: item.degree, value: item.uid}));
                            return response;
                        });
                },
                [services.getDegreeTypes]: (params) => {
                    return getDegreeTypes(params)
                        .then((response) => {
                            if (!response) {
                                throw new Error('Error fetch data from anabin');
                            }
                            response.data = (response.data ?? []).map(item => ({label: item.degreeType, value: item.uid}));
                            return response;
                        });
                },
            };

            return {
                services,
                serviceHelpers,
                getCountries,
                getUniversities,
                getDegrees,
                getDegreeTypes
            };
        };

        const useComponents = () => {
            // MAPPING
            const components = {
                text: "text",
                select: "select",
                radio: "radio",
                paragraph: "paragraph"
            };
            const defaultSelectOption = {
                label: 'Select an option',
                value: undefined
            };

            // UTILS
            const createElement = (el, parent) => {
                const element = document.createElement(el);
                parent.appendChild(element);
                return element;
            };
            const syncPoll = (fnToPoll, params, callback, next, catchFn, finallyFn) => {
                const finalParams = params ?? {};
                fnToPoll(params) // here params is intentional
                    .then(response => {
                        callback(response, finalParams);
                        const nextParams = next(response, finalParams);
                        if (nextParams) {
                            syncPoll(fnToPoll, nextParams, callback, next, catchFn, finallyFn);
                        }
                    })
                    .catch(catchFn)
                    .finally(() => {
                        finallyFn(finalParams);
                    });
            };
            // populates options for select tag
            // supports array as well as promise/api calls
            // can be used to repopulate the select tag
            const populateSelectOptions = (options, apiParams, events, parentSelect) => {
                if (!parentSelect) {
                    return;
                }
                if (typeof options === "function") {
                    parentSelect.setAttribute("disabled", "true");
                    const option = createElement("option", parentSelect);
                    option.innerHTML = "Loading...";

                    const callback = (response, localParams) => {
                        const { start = 0 } = localParams;
                        if (start === 0) {
                            if (!response?.data?.length) {
                                throw new Error('No options loaded');
                            }
                            parentSelect.innerHTML = "";
                            response.data.unshift(defaultSelectOption);
                        }
                        response.data.forEach((optionItem) => {
                            const optionEl = createElement("option", parentSelect);
                            optionEl.setAttribute("value", optionItem.value);
                            optionEl.innerHTML = optionItem.label;
                        });
                        parentSelect.removeAttribute("disabled");
                    };
                    const catchFn = (exception) => {
                        parentSelect.innerHTML = "";
                        const optionEl = createElement("option", parentSelect);
                        optionEl.innerHTML = "No options loaded";
                        optionEl.setAttribute("value", undefined);
                    };
                    const finallyFn = (localParams) => {
                        const { start = 0 } = localParams;
                        if (start === 0 && events.onChange) {
                            events.onChange(parentSelect.value);
                        }
                    };
                    const next = (localResponse, localParams) => {
                        // start = 0; pageSize = 10
                        // totalResponse = 36015; totalDisplayRecords = 34
                        const { start = 0, pageSize = 0 } = localParams;
                        const { totalResponse = 0, totalDisplayRecords = 0 } = localResponse;

                        const currentRecords = start + pageSize;
                        if (currentRecords < totalDisplayRecords) {
                            return {
                                ...localParams,
                                start: currentRecords
                            };
                        }
                    };
                    syncPoll(options, apiParams, callback, next, catchFn, finallyFn);
                    // options(apiParams)
                    //     .then((response) => {
                    //         if (!response.length) {
                    //             throw new Error('No options loaded');
                    //         }
                    //         parentSelect.innerHTML = "";
                    //         response.unshift(defaultSelectOption);
                    //         response.forEach((optionItem) => {
                    //             const optionEl = createElement("option", parentSelect);
                    //             optionEl.setAttribute("value", optionItem.value);
                    //             optionEl.innerHTML = optionItem.label;
                    //         });
                    //         parentSelect.removeAttribute("disabled");
                    //     })
                    //     .catch((exception) => {
                    //         parentSelect.innerHTML = "";
                    //         const optionEl = createElement("option", parentSelect);
                    //         optionEl.innerHTML = "No options loaded";
                    //         optionEl.setAttribute("value", undefined);
                    //     }).finally(() => {
                    //         if (events.onChange) {
                    //             events.onChange(parentSelect.value);
                    //         }
                    //     });
                } else {
                    parentSelect.innerHTML = "";
                    options.unshift(defaultSelectOption);
                    options.forEach((optionItem) => {
                        const option = createElement("option", parentSelect);
                        option.setAttribute("value", optionItem.value);
                        option.innerHTML = optionItem.label;
                    });
                    if (events.onChange) {
                        events.onChange(parentSelect.value);
                    }
                }
            };

            // COMPONENTS
            const createPrompt = (str, parent, type="success") => {
                const prompt = createElement("div", parent);
                prompt.setAttribute("role", "alert");
                prompt.classList.add("alert", `alert-${type}`);
                prompt.innerHTML = str;
                return prompt;
            };
            const createButton = (str, events, parent) => {
                const { onClick } = events;
                const buttonEl = createElement("button", parent);
                buttonEl.classList.add("btn", "btn-primary");
                buttonEl.setAttribute("type", "button");
                buttonEl.innerHTML = str;

                if (onClick) {
                    buttonEl.addEventListener('click', onClick);
                }

                return buttonEl;
            };

            // FORM COMPONENTS
            const createText = (item, events, parent) => {
                const { onChange } = events;
                const input = createElement("input", parent);
                input.classList.add('form-control');
                input.setAttribute("type", "text");
                input.setAttribute("id", item.id);
                if (item.props) {
                    if (item.props.placeholder) {
                        input.setAttribute("placeholder", item.props.placeholder);
                    }
                }

                if (onChange) {
                    input.addEventListener('change', () => {
                        onChange(input.value);
                    });
                }

                return input;
            };
            const createParagraph = (item, events, parent) => {
                const { onChange } = events;
                const input = createElement("textarea", parent);
                input.classList.add('form-control');
                input.setAttribute("id", item.id);
                if (item.props) {
                    if (item.props.placeholder) {
                        input.setAttribute("placeholder", item.props.placeholder);
                    }
                    input.setAttribute("rows", item.props.rows ?? 5);
                }

                if (onChange) {
                    input.addEventListener('change', () => {
                        onChange(input.value);
                    });
                }

                return input;
            };
            const createSelect = (item, events, parent) => {
                const { onChange } = events;
                const select = createElement("select", parent);
                select.setAttribute("id", item.id);
                select.classList.add('form-select');

                populateSelectOptions(item.props.options ?? [], item.props.apiParams, events, select);

                if (onChange) {
                    select.addEventListener('change', () => {
                        onChange(select.value);
                    });
                }
                
                return select;
            };
            const createRadio = (item, events, parent) => {
                const { onChange } = events;
                const radioGroup = [];
                item.props.options.forEach((optionItem, index) => {
                    const radioDiv = createElement("div", parent);
                    radioGroup.push(radioDiv);
                    radioDiv.classList.add("form-check");

                    const radioEl = createElement("input", radioDiv);
                    radioEl.classList.add("form-check-input");
                    radioEl.setAttribute("type", "radio");
                    radioEl.setAttribute("name", item.id);
                    radioEl.setAttribute("id", `${item.id}${index}`);
                    radioEl.setAttribute("value", optionItem.value);

                    const label = createElement("label", radioDiv);
                    label.classList.add("form-check-label");
                    label.setAttribute("for", `${item.id}${index}`);
                    label.innerHTML = optionItem.label;

                    if (onChange) {
                        radioEl.addEventListener("change", function () {
                            onChange(this.value);
                        })
                    }
                });

                

                return radioGroup;
            };

            // LIBRARY RETURN
            return {
                // constants
                components,
                // util
                createElement,
                populateSelectOptions,
                // components
                createButton,
                createPrompt,
                // form components
                createText,
                createParagraph,
                createSelect,
                createRadio
            };
        };

        const useValidations = () => {
            const { components, createElement } = useComponents();

            const defaultValidationMessage = 'This field requires attention';
            const validators = {
                required: 'required',
                onlyAlphabets: 'onlyAlphabets'
            };
            const validationHelpers = {
                [validators.required]: (value, options) => {
                    return !(value == null || value === '');
                },
                [validators.onlyAlphabets]: (value, options) => {
                    return !(/\d/.test(value));
                }
            };

            const resetValidations = (question) => {
                const fieldValidation = document.getElementById(`${question.id}-validation`);
                if (fieldValidation) {
                    fieldValidation.innerHTML = defaultValidationMessage;
                }
                if (question.type === components.radio) {
                    const fields = document.getElementsByName(question.id);
                    if (fields) {
                        fields.forEach(f => {
                            f.classList.remove('is-invalid');
                        });
                    }
                } else {
                    const field = document.getElementById(question.id);
                    if (field) {
                        field.classList.remove('is-invalid');
                    }
                }
            };
            const setValidations = (question, validation) => {
                if (!validation) {
                    return;
                }

                const fieldValidation = document.getElementById(`${question.id}-validation`);
                if (fieldValidation) {
                    fieldValidation.innerHTML = validation.message ?? defaultValidationMessage;
                }
                if (question.type === components.radio) {
                    const fields = document.getElementsByName(question.id);
                    if (fields) {
                        fields.forEach(f => {
                            f.classList.add('is-invalid');
                        });
                    }
                } else {
                    const field = document.getElementById(question.id);
                    if (field) {
                        field.classList.add('is-invalid');
                    }
                }
            };
            const createValidationUI = (question, inputField, parent) => {
                if (!question.props?.validations?.length) {
                    return;
                }

                let validationParent = parent;
                if (question.type === components.radio) {
                    validationParent = inputField[inputField.length - 1];
                }

                const validationDiv = createElement('div', validationParent);
                validationDiv.setAttribute('id', `${question.id}-validation`);
                validationDiv.classList.add('invalid-feedback');
                validationDiv.innerHTML = defaultValidationMessage;
            };

            const isValid = (form, output) => {
                let result = true;
                form.questions.forEach(item => {
                    if (!item.props?.validations?.length) {
                        return;
                    }
                    // reset field validations for each field
                    resetValidations(item);

                    // run validations in order for a field
                    const value = output[item.id];
                    let validation = null;
                    for (let i = 0; i < item.props.validations.length; i++) {
                        const localValidation = item.props.validations[i];
                        const output = validationHelpers[localValidation.type]
                            ? validationHelpers[localValidation.type](value, localValidation.options)
                            : true;
                        if (!output) {
                            result = false;
                            validation = localValidation;
                            break;
                        }
                    }

                    // show validation on field ui
                    setValidations(item, validation);
                });
                return result;
            };

            return {
                validators,
                isValid,
                createValidationUI
            };
        };

        const useFormRenderer = (
            forms,
            {
                onSubmit = (form, output, next) => { next(); },
                onBack = (next) => {},
                onFinalSubmit = ({
                    backSection,
                    stepSection,
                    questionSection,
                    submitSection
                }) => {},
                onOutputChange = (value, item, forms, output) => {}
            },
            output = {},
            app
        ) => {
            const {
                components,
                createElement,
                createText,
                createParagraph,
                createButton,
                createSelect,
                createPrompt,
                createRadio
            } = useComponents();
            const {
                createValidationUI,
                isValid
            } = useValidations();
            const { serviceHelpers } = useServices();

            // HTML elements
            let backSection = null;
            let stepSection = null;
            let questionSection = null;
            let submitSection = null;

            const animationTime = 300;

            // common change event, when any form element is changed
            const onChange = (value, item) => {
                // Update output
                output[item.id] = value;
                // Check affects dependencies and delete their values
                if (item.affects?.length) {
                    item.affects.forEach(id => {
                        if (item.type === components.radio) {
                            const els = document.getElementsByName(id);
                            if (els?.length) {
                                els.forEach(el => {
                                    el.checked = false;
                                });
                            }
                        } else {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = '';
                            }
                        }

                        output[id] = undefined;
                    });
                }
                onOutputChange(value, item, forms, output);
            };

            const createInput = (item, parent) => {
                const onLocalChange = (value) => {
                    onChange(value, item);
                };
                switch(item.type) {
                    case components.text: {
                        return createText(item, { onChange: onLocalChange }, parent);
                        break;
                    }
                    case components.paragraph: {
                        return createParagraph(item, { onChange: onLocalChange }, parent);
                        break;
                    }
                    case components.select: {
                        if (typeof item.props.options === 'string') {
                            item.props.options = serviceHelpers[item.props.options] ?? [];
                        }
                        return createSelect(item, { onChange: onLocalChange }, parent);
                        break;
                    }
                    case components.radio: {
                        return createRadio(item, { onChange: onLocalChange }, parent);
                        break;
                    }
                    default: {
                        return createText(item, { onChange: onLocalChange }, parent);
                        break;
                    }
                }
            };
            const renderQuestion = (question, parent) => {
                const qParentDiv = createElement('div', parent);
                qParentDiv.classList.add('mb-3');
                const qDiv = createElement('label', qParentDiv);
                qDiv.setAttribute('for', question.id);
                qDiv.classList.add('form-label');
                qDiv.innerHTML = question.question;

                const inputField = createInput(question, qParentDiv);

                createValidationUI(question, inputField, qParentDiv);

                if (question.prompt) {
                    const promptEl = createPrompt(question.prompt, qParentDiv);
                    promptEl.classList.add("form-prompt");
                }
            };
            const renderQuestions = ({ id, questions }, parent) => {
                const section = createElement('form', parent);
                section.setAttribute("id", id);
                questions.forEach((question) => {
                    renderQuestion(question, section);
                });
            };
            const renderSteps = (index, total, parent) => {
                const form = forms[index];

                const stepNo = createElement('div', parent);
                stepNo.innerHTML = `Step ${index + 1}/${total}`;
                stepNo.classList.add('step-no');

                const progressBarDiv = createElement('div', parent);
                progressBarDiv.classList.add('position-relative', 'height-6');
                const progressBackground = createElement('span', progressBarDiv);
                progressBackground.classList.add('progress', 'progress-back');
                progressBackground.style.width = '100px';
                const progressBar = createElement('span', progressBarDiv);
                progressBar.classList.add('progress', 'progress-bar');
                progressBar.style.width = `${((index + 1)/total) * 100}px`;

                const stepTitle = createElement('div', parent);
                stepTitle.innerHTML = form.name;

            };
            const renderForm = (form, index, total) => {
                // reset
                backSection.innerHTML = '';
                stepSection.innerHTML = '';
                questionSection.classList.remove('myfade-in');
                setTimeout(() => {
                    questionSection.innerHTML = '';
                }, animationTime);
                submitSection.innerHTML = '';

                // back section
                if (index > 0 && index < total) {
                    const backSpan = createElement('span', backSection);
                    const backIcon = createElement("i", backSpan);
                    backIcon.classList.add("fas", "fa-arrow-left");

                    backSpan.classList.add('cursor-pointer');
                    backSpan.addEventListener("click", () => {
                        onBack(() => {
                            if (index > 0) {
                                index--;
                                renderForm(forms[index], index, total);
                            }
                        });
                    });
                }

                // step section
                if (index < total) {
                    renderSteps(index, total, stepSection);
                }

                // question section
                setTimeout(() => {
                    const title = createElement('h3', questionSection);
                    title.innerHTML = form.title;

                    renderQuestions(form, questionSection);
                    questionSection.classList.add('myfade-in');
                }, animationTime);

                // submit section
                if (index < total) {
                    const onClick = () => {
                        // Validate data
                        if (isValid(form, output)) {
                            onSubmit(form, output, () => {
                                if (index < (total - 1)) {
                                    index++;
                                    renderForm(forms[index], index, total);
                                } else {
                                    onFinalSubmit({
                                        backSection,
                                        stepSection,
                                        questionSection,
                                        submitSection
                                    });
                                }
                            });
                        }
                    };
                    const submitBtn = createButton("Submit", { onClick }, submitSection);
                }
            };
            const init = () => {
                backSection = createElement("div", app);
                backSection.classList.add('back-section');

                stepSection = createElement('div', app);
                stepSection.classList.add('step-section');

                questionSection = createElement("div", app);
                questionSection.classList.add('myfade', 'margin-top-20');

                submitSection = createElement("div", app);

                renderForm(forms[0], 0, forms.length);
            };

            return {
                init
            };
        };

        (() => {
            const app = document.getElementById("quizApp");
            if (!app)
                return;

            app.innerHTML = "";

            const {
                components,
                createElement,
                populateSelectOptions
            } = useComponents();
            const {
                validators,
                isValid
            } = useValidations();
            const { services } = useServices();

            const forms = [
                {
                    id: "personalDetails",
                    name: "Personal Details",
                    title: "Personal Details",
                    questions: [
                        {
                            id: "surname",
                            question: "Surname",
                            type: components.text,
                            props: {
                                placeholder: "Enter your surname",
                                validations: [
                                    { type: validators.required, message: 'Please enter your surname' },
                                    { type: validators.onlyAlphabets, message: 'Numbers are not allowed' }
                                ],
                            }
                        },
                        {
                            id: "givenName",
                            question: "Given Name",
                            type: components.text,
                            props: {
                                placeholder: "Enter your given name"
                            }
                        },
                        {
                            id: "nationality",
                            question: "Nationality",
                            type: components.text,
                            props: {
                                placeholder: "Select your nationality",
                                validations: [
                                    { type: validators.required, message: 'Please enter your nationality' }
                                ],
                            }
                        },
                        {
                            id: "dualCitizenship",
                            question: "Posesses Dual Citizenship",
                            type: components.radio,
                            props: {
                                options: [
                                    { label: "Yes", value: "Yes" },
                                    { label: "No", value: "No" },
                                ],
                                validations: [
                                    { type: validators.required, message: 'Please select an option' },
                                ],
                            }
                        },
                        {
                            id: "citizenshipList",
                            question: "If yes, please list",
                            type: components.paragraph,
                            props: {
                                placeholder: "List of citizenships",
                                validations: [
                                    { type: validators.required, message: 'Please enter the list citizenships' }
                                ],
                            }
                        },
                    ]
                },
                {
                    id: "residenceDetails",
                    name: "Residence Details",
                    title: "Residence and travel information",
                    questions: [
                        {
                            id: "duration",
                            question: "Intended duration of residency in Germany",
                            type: components.text,
                            props: {
                                placeholder: "in years"
                            }
                        },
                        {
                            id: "previousVisit",
                            question: "Have you previously visited Germany?",
                            type: components.radio,
                            props: {
                                options: [
                                    { label: "Yes", value: "Yes" },
                                    { label: "No", value: "No" },
                                ]
                            }
                        },
                        {
                            id: "visitDates",
                            question: "If yes, please list all dates",
                            type: components.paragraph,
                            props: {
                                placeholder: "enter to and from dates on different lines"
                            }
                        },
                        {
                            id: "currentResidence",
                            question: "Current place of residence",
                            type: components.text,
                            props: {
                                placeholder: "Current country and province/state"
                            }
                        },
                    ]
                },
                {
                    id: "professionalDetails",
                    name: "Professional Details",
                    title: "Professional background",
                    questions: [
                        {
                            id: "purpose",
                            question: "Purpose of your visit to Germany",
                            type: components.text,
                            props: {
                                placeholder: "Enter the purpose"
                            }
                        },
                        {
                            id: "expertise",
                            question: "Primary area of expertise",
                            type: components.text,
                            props: {
                                placeholder: "industry or field"
                            }
                        },
                        {
                            id: "interestedPositions",
                            question: "Positions you are interested in (list five)",
                            type: components.paragraph,
                            props: {
                                placeholder: "list on different lines"
                            }
                        },
                        {
                            id: "experience",
                            question: "Total professional experience",
                            type: components.text,
                            props: {
                                placeholder: "in years"
                            }
                        },
                    ]
                },
                {
                    id: "educationDetails",
                    name: "Education Details",
                    title: "Educational background",
                    questions: [
                        {
                            id: "educationCountry",
                            question: "Country of degree attainment",
                            type: components.select,
                            props: {
                                placeholder: "Select country",
                                options: services.getCountries,
                            },
                            affects: ["educationLevel", "university", "degree"]
                        },
                        {
                            id: "educationLevel",
                            question: "Highest level of education attained",
                            type: components.select,
                            props: {
                                placeholder: "Select level",
                                options: services.getDegreeTypes,
                                apiParams: {
                                    pageSize: 100,
                                    educationCountry: null,
                                    educationLevel: null
                                }
                            },
                            affects: ["degree"]
                        },
                        {
                            id: "university",
                            question: "Complete University name",
                            type: components.select,
                            props: {
                                placeholder: "Select university name",
                                options: services.getUniversities,
                                apiParams: {
                                    pageSize: 500,
                                    educationCountry: null
                                }
                            }
                        },
                        {
                            id: "degree",
                            question: "Complete degree name",
                            type: components.select,
                            props: {
                                placeholder: "Select degree name",
                                options: services.getDegrees,
                                apiParams: {
                                    pageSize: 100,
                                    educationCountry: null,
                                    educationLevel: null
                                }
                            }
                        },
                        {
                            id: "recognition",
                            question: "Has your university degree been officially recognized in Germany?",
                            type: components.radio,
                            props: {
                                options: [
                                    { label: "Yes", value: "Yes" },
                                    { label: "No", value: "No" },
                                ]
                            }
                        },
                    ]
                },
                {
                    id: "employmentDetails",
                    name: "Employment Details",
                    title: "Employment information",
                    questions: [
                        {
                            id: "germanEmployment",
                            question: "Do you currently hold an employment contract or a confirmed job offer in Germany?",
                            type: components.radio,
                            props: {
                                options: [
                                    { label: "Yes", value: "Yes" },
                                    { label: "No", value: "No" },
                                ]
                            }
                        },
                        {
                            id: "germanCompanyList",
                            question: "If yes, list company name and contact person",
                            type: components.paragraph,
                            props: {
                                placeholder: "Enter on different lines"
                            }
                        },
                        {
                            id: "expectedIncome",
                            question: "Anticipated Gross Income for the Intended Job",
                            prompt: `
                                For IT professionals and bottleneck professions - eligible
                                For Blue card if salary is €39,682.80 or above - eligible
                                For other regular occupations they are eligible for Blue Card if salary is €43,800 or above - eligible
                            `,
                            type: components.text,
                            props: {
                                placeholder: "enter amount as per annum",
                            }
                        }
                    ]
                },
            ];
            const output = {};

            const onSubmit = (form, output, next) => {
                next();
            };
            const onBack = (next) => {
                next();
            };
            const onFinalSubmit = ({
                backSection,
                stepSection,
                questionSection,
                submitSection
            }) => {
                backSection.innerHTML = '';
                stepSection.innerHTML = '';
                questionSection.innerHTML = 'Thank you for filling the survey';
                submitSection.innerHTML = '';
            };
            // this function is used to detect change in field which affects others and further populates the new option list for select tag for now
            const onOutputChange = (localValue, localItem, localForms, localOutput) => {
                if (!localItem.affects?.length) {
                    return;
                }

                const affectedItems = {};
                localItem.affects.forEach(id => {
                    // Get all affected field schemas
                    forms.forEach(form => {
                        (form.questions || []).forEach(questionItem => {
                            if (questionItem.id === id) {
                                affectedItems[id] = questionItem;
                            }
                        });
                    });
                });

                if (!Object.keys(affectedItems).length) {
                    return;
                }
                
                Object.keys(affectedItems).forEach(key => {
                    const affectedItem = affectedItems[key];
                    // checks for each affected field which is a select field
                    // and has a promise, which means it will dynamically update
                    // if static array or undefined .. no action required
                    if (
                        affectedItem.type !== components.select
                        || (
                            typeof affectedItem.props?.options !== 'string'
                            && typeof affectedItem.props?.options !== 'function'
                        )
                    ) {
                        return;
                    }
                    
                    // need to call apis
                    // prepare apiParams first
                    const { apiParams } = affectedItem.props;
                    if (apiParams) {
                        // check if any key in the apiParams are available in the output object
                        // if so then update the latest value in apiParams
                        Object.keys(apiParams).forEach(key => {
                            if (output[key] == null) {
                                return;
                            }
                            
                            apiParams[key] = output[key];
                            // some params need to be renamed/duplicated because of the api param names
                            // country and countryCode
                            if (apiParams[key] && key.toLocaleLowerCase().includes('country')) {
                                apiParams.countryCode = apiParams[key];
                                const country = (store.countries ?? []).find(item => item.code == apiParams.countryCode);
                                if (country) {
                                    apiParams.country = country.name;
                                }
                            }
                            // degreeTypeId
                            if (apiParams[key] && key === 'educationLevel') {
                                apiParams.degreeTypeId = apiParams[key];
                            }
                        });
                    }
                    // re-populate the affected select options
                    populateSelectOptions(
                        affectedItem.props.options,
                        affectedItem.props.apiParams,
                        {
                            onChange: (value) => { output[affectedItem.id] = value; }
                        },
                        document.getElementById(affectedItem.id)
                    );
                });
            };

            const {
                init
            } = useFormRenderer(
                forms,
                {
                    onSubmit,
                    onBack,
                    onFinalSubmit,
                    onOutputChange,
                },
                output,
                app,
            );
            init();

        })();
    </script>
</body>
</html>